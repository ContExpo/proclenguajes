//*****************************************************************
// File:   adac_4.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//		   Para ejecutar el jar: java -jar ruta_jar < ruta_prog_prueba
//*****************************************************************

options {
  // IGNORE_CASE = false;
  // COMMON_TOKEN_ACTION = false;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(adac_4)
package traductor;
import java.util.Set;
import java.util.HashSet;
import lib.symbolTable.*;
import lib.errores.*;
import lib.attributes.Attributes;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;
import lib.tools.codeGeneration.*;

public class adac_4 {

	static SymbolTable st = new SymbolTable();
	static ErrorSemantico es;
	static CGUtils cgu;
	//Variable booleana para decidir si se genera código para hacer comprobaciones
	//en tiempo de ejecución
	static boolean genErrEjec = true;
	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
			"procedure", "function", "val", "ref", "integer", "character", "boolean", "is", "begin", "end",
			"if", "else","while", "then", "return", "mod", "div", "true", "false", "not", "and", "function",
			"get", "char2int", "int2char", "skip_line", "put", "put_line"
		};

		st.insertReservedWords(palsRes);
	}

    public static void main(String[] args) {
		adac_4 parser;
		try {
	    	if(args.length == 0) { //entrada desde stdin
				System.err.println ("Hay que pasar exactamente un parametro, el nombre del fichero que compilar sin .pcode");
				return;
			}
			else { //entrada desde fichero en args[0]
				parser = new adac_4(new java.io.FileInputStream(args[0])); 
			}
			parser.S(args[0]); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
			System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac_4)
//------------ descripción del AL

TOKEN_MGR_DECLS : 
{
	static void printToken (Token t, String s) {
		System.out.printf("(%d, %d): \"%s\" %s\n", t.beginLine,
		t.beginColumn, t.image, s );
	}
}

TOKEN :
{
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #NUM : (<DIGIT>)+ >
|	< #WORD: ["a"-"z","A"-"Z"](~[" ","\t","\n","\r","0"-"9"])*>
}

SKIP :
{
	
	< " " | "\t" | "\r" | "\n" >	// Espacios en blanco
|	< "--"(~["\n", "\r"])* >				// Comentarios
}

TOKEN :
{
	< tCHAR: "'" (~["\n","\r","'"]) "'" >
|	< tSTRING: "\"" (~["\n","\r", "\""] | "\"\"")* "\"" >
|	< tNUM: <NUM> >
|	< tPROC: "procedure" >
|	< tIS: "is" >
| 	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tRET: "return" >
|	< tBOOL: "boolean" >
|	< tCHDECL: "character" >
|   < tINT:  "integer" >
|   < tNOT:  "not" >
|   < tOR:  "or" >
|   < tAND:  "and" >
|   < tIF:  "if" >
|   < tTHEN:  "then" >
|   < tELSE:  "else" >
|   < tWHIL:  "while" >
|   < tDO:  "do" >
|	< tCOMMA:  "," >
|	< tSCOL:  ";" >
|	< tPTOP:  "(" >
|	< tPTCL:  ")" >
|	< tSQOP:  "[" >
|	< tSQCL:  "]" >
|	< tSQUOT:  "'" >
|	< tDQUOT:  "\"" >
|   < tASIG:  ":=" >
|	< tADD:  "+" >
|	< tSUB:  "-" >
|	< tMUL:  "*" >
|	< tDIV:  "div" >
|	< tMOD:  "mod" >
|	< tGT:  ">" >
|	< tLT:  "<" >
|	< tEQ:  "=" >
|	< tGEQ:  ">=" >
|	< tLEQ:  "<=" >
|	< tDIFF:  "<>" >
|	< tTRUE:  "true" >
|	< tFALSE:  "false" >
|	< tATOI:  "char2int" >
|	< tITOA:  "int2char" >
|	< tGET:  "get" >
|	< tSKIPL:  "skip_line" >
|	< tPUT:  "put" >
|	< tPUTL:  "put_line" >
|	< tFUNC: "function" >
|	< tVAL: "val" >
|	< tREF: "ref" >
|	< tID: <LETTER> ( ("_")? (<DIGIT> | <LETTER>) )* >
}
SPECIAL_TOKEN:
{
	< ~[] >
		{
			System.err.print("LEXICAL ERROR: ");
			System.err.printf("(%d, %d): unrecognized symbol: %s", matchedToken.beginLine,
			matchedToken.beginColumn, matchedToken.image );
		}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S (String fileName) : 
{
	CodeBlock cb = new CodeBlock();
	Token t1 = new Token();
	String mainLabel = "";
	Attributes dec_vars, dec_procs_funcs, main;
}
{
	try {
		<tPROC>
		t1 = <tID>
		<tIS>
		{
			cgu.memorySpaces[st.level] = 3;
			SymbolProcedure s = new SymbolProcedure(t1.image, new ArrayList<Symbol>());
			st.insertSymbol(s);
			cb.addComment("Programa " + t1.image);
			mainLabel = cgu.newLabel();
			cb.addInst(PCodeInstruction.OpCode.ENP, mainLabel);
		}
		dec_vars = declaracion_variables()
		{
			cb.addBlock(dec_vars.block);
		}
		dec_procs_funcs = declaracion_procs_funcs()
		{
			cb.addBlock(dec_procs_funcs.block);
			cb.addLabel(mainLabel);
		}
		main = bloque_sentencias(t1.image, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED)
		{
			cb.addBlock(main.block);
		}
		<EOF>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
	{
		cb.addInst(PCodeInstruction.OpCode.LVP);
		cb.encloseXMLTags(t1.image);
		
		//Generar código solo si no hay errores
		if (es.getContadorErrores() == 0) {
			File file = new File(fileName + ".pcode");
			file.writeLine("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
			file.writeLine(cb.toString());
			file.close()
			System.out.println("Compilado correctamente el fichero " + fileName + ".pcode");
		} else {
			System.out.println("Presencia de errores en el fichero fuente. Abortada la generación de código.");
		}
	}
}

//declaracion_variables : ( declaracion <tSCOL> )*
Attributes declaracion_variables() :
{
	Attributes a = new Attributes();
	Attributes temp;
}
{
	try {
		(
			temp = declaracion()
			<tSCOL>
			{
				a.block.addBlock(temp.block);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		a.block.encloseXMLTags("declaracion_variables");
		return a;
	}	
}

//declaracion : tipo_variable lista_vars
Attributes declaracion() :
{
	Symbol.Types type;
	ArrayList<Attributes> vars, temp;
	Attributes toRet = null;
}
{
	try {
		type = tipo_variable()
		toRet = lista_vars(type)
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

// tipo_variable : <tINT> | <tCHDECL> | <tBOOL>
Symbol.Types tipo_variable() :
{
	
}
{
	try {
		<tINT>
		{
			return Symbol.Types.INT;
		}
	|	<tCHDECL>
		{
			return Symbol.Types.CHAR;
		}
	|	<tBOOL>
		{
			return Symbol.Types.BOOL;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//lista_vars : variable ( <tCOMMA> variable )*
Attributes lista_vars(Symbol.Types type) :
{
	Attributes a = new Attributes();
	Attributes temp;
}
{
	try {
		temp = variable(type)
		{
			a.block.addBlock(temp.block);
		}
		(
			<tCOMMA>
			temp = variable(type)
			{
				a.block.addBlock(temp.block);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return a;
	}
}

//variable : LOOKAHEAD(2)
//				<tID> <tACOR> <tCONST_INT> <tCCOR>
//			|	<tID>
Attributes variable(Symbol.Types type) :
{
	Token t1;
	Token t2;
	Attributes a = new Attributes();

}
{
	try {
		LOOKAHEAD(2)
		t1 = <tID>
		<tSQOP>
		t2 = <tNUM>
		<tSQCL>
		{
			try {
				SymbolArray sArr = new SymbolArray(t1.image, Integer.parseInt(t2.image), type);
				sArr.dir = cgu.memorySpaces[st.level];
				//Reservar tanto espacio en memoria como componentes tenga el vector
				int tamanyo = sArr.maxInd - sArr.minInd + 1;
				cgu.memorySpaces[st.level] += tamanyo;
				st.insertSymbol(sArr);
				a.block.addComment(String.format("Variable %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d:%d]!",
					sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir, sArr.dir + tamanyo - 1));
			} catch(AlreadyDefinedSymbolException e) {
				System.err.println("Error: " + t1.image + " ya está declarado");
			}
		}
	|	t1 = <tID>
		{
			try {
				switch (type) {
					case INT : 
						SymbolInt sInt = new SymbolInt(t1.image);
						sInt.dir = cgu.memorySpaces[st.level]++;
						st.insertSymbol(sInt);
						a.block.addComment(String.format("Variable %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
							sInt.name, sInt.type, sInt.parClass, sInt.nivel, sInt.dir));
						break;
						
					case CHAR : 
						SymbolChar sChar = new SymbolChar(t1.image);
						sChar.dir = cgu.memorySpaces[st.level]++;
						st.insertSymbol(sChar);
						a.block.addComment(String.format("Variable %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
							sChar.name, sChar.type, sChar.parClass, sChar.nivel, sChar.dir));
						break;
						
					case BOOL :
						SymbolBool sBool = new SymbolBool(t1.image);
						sBool.dir = cgu.memorySpaces[st.level]++;
						st.insertSymbol(sBool);
						a.block.addComment(String.format("Variable %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
							sBool.name, sBool.type, sBool.parClass, sBool.nivel, sBool.dir));
						break;
					default: es.deteccion("Error: " + type + " no es un tipo válido", token);
				}
			} catch(AlreadyDefinedSymbolException e) {
				System.err.println("Error: " + t1.image + " ya está declarado");
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return a;
	}
}

//declaracion_procs_funcs : ( declaracion_proc_func )*
Attributes declaracion_procs_funcs() :
{
	Attributes toRet = new Attributes();
	Attributes decPF = null;
}
{
	try {
		(
			decPF = declaracion_proc_func()
			{
				toRet.block.addBlock(decPF.block);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//declaracion_proc_func :	declaracion_proceso
//						|	declaracion_funcion
Attributes declaracion_proc_func() :
{
	Attributes toRet = null;
}
{
	try {
		toRet = declaracion_proceso()
	|	toRet = declaracion_funcion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//declaracion_proceso : cabecera_proceso declaracion_variables declaracion_procs_funcs bloque_sentencias
Attributes declaracion_proceso() :
{
	Attributes attrCab;
	Attributes attrDecl;
	Attributes attrDeclPF;
	Attributes attrBloque;
	Attributes toRet = new Attributes();
}
{
	try {
		attrCab = cabecera_proceso()
		{
			toRet.block.addBlock(attrCab.block);
		}
		attrDecl = declaracion_variables()
		{
			toRet.block.addBlock(attrDecl.block);
		}
		attrDeclPF = declaracion_procs_funcs()
		{
			toRet.block.addBlock(attrDeclPF.block);
			//Añadimos la etiqueta de inicio del procedimiento
			//Dentro de cabecera_funcion ya se ha reservado ésta dirección
			toRet.block.addLabel("L"+(attrCab.simbolo.dir+1));
		}
		attrBloque = bloque_sentencias(attrCab.name, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED)
		{
			toRet.block.addBlock(attrBloque.block);
			toRet.block.encloseXMLTags("procedimiento_" + attrCab.name);
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//cabecera_proceso : <tPROC> <tID> ( decs_parametros )? <tIS>
Attributes cabecera_proceso() :
{
	Attributes toRet = new Attributes();
	Token t1 = new Token();
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tPROC>
		t1 = <tID>
		(
			parList = decs_parametros()
		)?
		<tIS>
		{
			SymbolProcedure s = new SymbolProcedure(t1.image, parList);
			
			//El procedimiento no lo queremos reservar en memoria.
			//Solo necesitamos saber cuál es el número de su etiqueta de inicio
			String labelInicio = cgu.newLabel();
			s.dir = Integer.parseInt(labelInicio.substring(1));
			
			st.insertSymbol(s);
			st.insertBlock();
			cgu.memorySpaces[st.level] = 3;
			
			//Generación de la etiqueta de inicio
			toRet.block.addLabel("L"+s.dir);
			
			for (Symbol par : parList) {
				par.dir = cgu.memorySpaces[st.level]++;
				st.insertSymbol(par);
				
				//Comentario de declaración de parámetro
				//Distinción del caso de vector
				if (par.type == Symbol.Types.ARRAY) {
					SymbolArray sArr = (SymbolArray) par;
					int tamanyo = sArr.maxInd - sArr.minInd + 1;
					
					//En caso de ser vector por referencia, no hace falta declarar cada componente,
					//solo la dirección de inicio
					if (par.parClass == Symbol.ParameterClass.REF) {
						toRet.block.addComment(String.format("Parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir));
					} else {
						cgu.memorySpaces[st.level] += tamanyo - 1;
						
						toRet.block.addComment(String.format("Parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d:%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir, sArr.dir + tamanyo - 1));
					}
				} else {
					toRet.block.addComment(String.format("Parámetro %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
								par.name, par.type, par.parClass, par.nivel, par.dir));
				}
			}
			
			//Recuperación de cada variable en el stack (en orden inverso)
			for (int i = parList.size()-1; i >= 0; i--) {
				Symbol par = parList.get(i);
				CodeBlock cod = new CodeBlock();
				
				//Distinción del caso de vector
				if (par.type == Symbol.Types.ARRAY) {
					SymbolArray sArr = (SymbolArray) par;
					int tamanyo = sArr.maxInd - sArr.minInd + 1;
					
					//En caso de ser vector por referencia, no hace falta recuperar cada componente,
					//solo la dirección de inicio
					if (par.parClass == Symbol.ParameterClass.REF) {
						cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir));
						
						cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , (int)par.dir);
						cod.addInst(PCodeInstruction.OpCode.ASGI);
					} else {
						cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d:%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir, sArr.dir + tamanyo - 1));
						
						for (int j = (int)sArr.dir + tamanyo - 1; j >= sArr.dir; j--) {
							cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , j);
							cod.addInst(PCodeInstruction.OpCode.ASGI);
						}
					}
				} else {
					cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
								par.name, par.type, par.parClass, par.nivel, par.dir));
					
					cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , (int)par.dir);
					cod.addInst(PCodeInstruction.OpCode.ASGI);
				}
				
				cod.encloseXMLTags(String.format("recuperar_parámetro_%d",i+1));
				toRet.block.addBlock(cod);
			}
			//Sabemos que siempre vamos a saltar al label siguiente del de inicio de función
			toRet.block.addInst(PCodeInstruction.OpCode.JMP, cgu.newLabel());
			
			toRet.type = s.type;
			toRet.name = s.name;
			toRet.simbolo = s;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
	{
		return toRet;
	}
}



//declaracion_funcion : cabecera_funcion declaracion_variables declaracion_procs_funcs bloque_sentencias
Attributes declaracion_funcion() :
{
	Attributes attrCab;
	Attributes attrDecl;
	Attributes attrDeclPF;
	Attributes attrBloque;
	Attributes toRet = new Attributes();
}
{
	try {
		attrCab = cabecera_funcion()
		{
			toRet.block.addBlock(attrCab.block);
		}
		attrDecl = declaracion_variables()
		{
			toRet.block.addBlock(attrDecl.block);
		}
		attrDeclPF = declaracion_procs_funcs()
		{
			toRet.block.addBlock(attrDeclPF.block);
			//Añadimos la etiqueta de inicio de la función
			//Dentro de cabecera_funcion ya se ha reservado ésta dirección
			toRet.block.addLabel("L"+(attrCab.simbolo.dir+1));
		}
		attrBloque = bloque_sentencias(attrCab.name, Symbol.Types.FUNCTION, attrCab.type)
		{
			toRet.block.addBlock(attrBloque.block);
			toRet.block.encloseXMLTags("función_" + attrCab.name);
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//cabecera_funcion : <tFUNC> tipo_variable <tID> ( decs_parametros )? <tIS>
Attributes cabecera_funcion() :
{
	Attributes toRet = new Attributes();
	Token t1 = new Token();
	Symbol.Types type;
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tFUNC>
		type = tipo_variable()
		t1 = <tID>
		(
			parList = decs_parametros()
		)?
		<tIS>
		{
			SymbolFunction s = new SymbolFunction(t1.image, parList, type);
			
			//La función no la queremos reservar en memoria.
			//Solo necesitamos saber cuál es el número de su etiqueta de inicio
			String labelInicio = cgu.newLabel();
			s.dir = Integer.parseInt(labelInicio.substring(1));
			
			st.insertSymbol(s);
			st.insertBlock();
			cgu.memorySpaces[st.level] = 3;
			
			//Generación de la etiqueta de inicio
			toRet.block.addLabel("L"+s.dir);
			
			for (Symbol par : parList) {
				par.dir = cgu.memorySpaces[st.level]++;
				st.insertSymbol(par);
				
				//Comentario de declaración de parámetro
				//Distinción del caso de vector
				if (par.type == Symbol.Types.ARRAY) {
					SymbolArray sArr = (SymbolArray) par;
					int tamanyo = sArr.maxInd - sArr.minInd + 1;
					
					//En caso de ser vector por referencia, no hace falta declarar cada componente,
					//solo la dirección de inicio
					if (par.parClass == Symbol.ParameterClass.REF) {
						toRet.block.addComment(String.format("Parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir));
					} else {
						cgu.memorySpaces[st.level] += tamanyo - 1;
						
						toRet.block.addComment(String.format("Parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d:%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir, sArr.dir + tamanyo - 1));
					}
				} else {
					toRet.block.addComment(String.format("Parámetro %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
								par.name, par.type, par.parClass, par.nivel, par.dir));
				}
			}
			
			//Recuperación de cada variable en el stack (en orden inverso)
			for (int i = parList.size()-1; i >= 0; i--) {
				Symbol par = parList.get(i);
				CodeBlock cod = new CodeBlock();
				
				//Distinción del caso de vector
				if (par.type == Symbol.Types.ARRAY) {
					SymbolArray sArr = (SymbolArray) par;
					int tamanyo = sArr.maxInd - sArr.minInd + 1;
					
					//En caso de ser vector por referencia, no hace falta recuperar cada componente,
					//solo la dirección de inicio
					if (par.parClass == Symbol.ParameterClass.REF) {
						cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir));
						
						cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , (int)par.dir);
						cod.addInst(PCodeInstruction.OpCode.ASGI);
					} else {
						cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, de tamaño %d, por %s, nivel %d, dirección[%d:%d]!",
							sArr.name, sArr.type + "[" + sArr.baseType + "]", tamanyo, sArr.parClass, sArr.nivel, sArr.dir, sArr.dir + tamanyo - 1));
						
						for (int j = (int)sArr.dir + tamanyo - 1; j >= sArr.dir; j--) {
							cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , j);
							cod.addInst(PCodeInstruction.OpCode.ASGI);
						}
					}
				} else {
					cod.addComment(String.format("Recuperando parámetro %s, de tipo %s, por %s, nivel %d, dirección[%d]!",
								par.name, par.type, par.parClass, par.nivel, par.dir));
					
					cod.addInst(PCodeInstruction.OpCode.SRF, st.level - par.nivel , (int)par.dir);
					cod.addInst(PCodeInstruction.OpCode.ASGI);
				}
				
				cod.encloseXMLTags(String.format("recuperar_parámetro_%d",i+1));
				toRet.block.addBlock(cod);
			}
			//Sabemos que siempre vamos a saltar al label siguiente del de inicio de función
			toRet.block.addInst(PCodeInstruction.OpCode.JMP, cgu.newLabel());
			
			toRet.type = s.returnType;
			toRet.name = s.name;
			toRet.simbolo = s;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
	{
		return toRet;
	}
}

//bloque_sentencias : <tBEGIN> ( instruccion )* <tEND>
Attributes bloque_sentencias(String nom, Symbol.Types proc_or_func, Symbol.Types retType) :
{
	boolean hayReturn = false;
	boolean aux = false;
	Attributes temp = null;
	Attributes toRet = new Attributes();
}
{
	try {
		<tBEGIN>
		{
			System.err.println("***********************");
			System.err.println("Procesando " + nom);
			System.err.println("***********************");
		}
		(
			temp = instruccion()
			{
				toRet.block.addBlock(temp.block);
				aux = temp.hayReturn;
				hayReturn |= aux;
			}
		)*
		<tEND>
		{
			if (proc_or_func == Symbol.Types.FUNCTION && !hayReturn) {
				System.err.println("Error: No hay return en la función");
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		//Si no estamos en el bloque de instrucciones del procedimiento principal
		//hay que añadir la instrucción para recuperar el stack frame
		//toRet.block.addComment("Bloque de instrucciones de nivel "+st.level);
		if (st.level > 0) {
			toRet.block.addInst(PCodeInstruction.OpCode.CSF);
		}
		toRet.block.encloseXMLTags("bloque_instrucciones_"+nom);
		//System.err.println(st.toString());
		st.removeBlock();
		return toRet;
	}
}

//decs_parametros : <tPTOP> ( dec_parametros ( <tSCOL> dec_parametros )* )? <tPTCL>
ArrayList<Symbol> decs_parametros() :
{
	ArrayList<Symbol> partialList = new ArrayList<Symbol>();
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tPTOP>
		(
			partialList = dec_parametros()
			(
				<tSCOL>
				{
					parList.addAll(partialList);
				}
				partialList = dec_parametros()
			)*
		)?
		<tPTCL>
		{
			parList.addAll(partialList);
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return parList;
	}
}

//dec_parametros : clase_parametros tipo_variable id_or_array ( <tCOMMA> id_or_array )*
ArrayList<Symbol> dec_parametros() :
{
	Symbol.ParameterClass parClass = Symbol.ParameterClass.NONE;
	Symbol.Types type;
	Symbol par;
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		parClass = clase_parametros() //Si es ref o val
		type = tipo_variable()	//Si es string, int...
		par = id_or_array(type)	//El token
		{
			par.parClass = parClass;
			parList.add(par);
		}
		(
			<tCOMMA>
			par = id_or_array(type)
			{
				par.parClass = parClass;
				parList.add(par);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return parList;
	}
}

//id_or_array : LOOKAHEAD(2)
//					<tID> <tSQOP> <tNUM> <tSQCL>
//				|	<tID>
Symbol id_or_array(Symbol.Types type) :
{
	Token t1;
	Token t2;
}
{
	try {
		LOOKAHEAD(2)
		t1 = <tID>
		<tSQOP>
		t2 = <tNUM>
		<tSQCL>
		{
			return new SymbolArray(t1.image, Integer.parseInt(t2.image), type);
		}
	|	t1 = <tID>
		{
			switch (type) {
				case INT : 
					return new SymbolInt(t1.image);
					break;
					
				case CHAR : 
					return new SymbolChar(t1.image);
					break;
					
				case BOOL :
					return new SymbolBool(t1.image);
					break;
				default: System.err.println("Error: " + type + " no es un tipo válido");
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//clase_parametros:	<tREF>
//				|	<tVAL>
Symbol.ParameterClass clase_parametros() :
{
	
}
{
	try {
		<tREF>
		{
			return Symbol.ParameterClass.REF;
		}
	|	<tVAL>
		{
			return Symbol.ParameterClass.VAL;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//instruccion : 	inst_leer <tSCOL>
//				|	inst_saltar_linea <tSCOL> 
//				|	inst_escribir <tSCOL> 
//				|	inst_escribir_linea <tSCOL> 
//				|LOOKAHEAD(2)
//					inst_invoc_proc <tSCOL> 
//				|	inst_asignacion <tSCOL> 
//				|	inst_seleccion
//				|	inst_iteracion
//				|	inst_return <tSCOL>
Attributes instruccion() :
{
	Attributes ret = new Attributes();
}
{
	try {
		ret = inst_leer()
		<tSCOL>
	|	ret = inst_saltar_linea()
		<tSCOL>
	|	ret = inst_escribir()
		<tSCOL>
	|	ret = inst_escribir_linea() 
		<tSCOL>
	|LOOKAHEAD(2)
		ret = inst_invoc_proc()
		<tSCOL>
	|	ret = inst_asignacion()
		<tSCOL>
	|	ret = inst_seleccion()
	|	ret = inst_iteracion()
	|	ret = inst_return()
		<tSCOL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return ret;
	}
}

//inst_leer : <tGET> <tPTOP> asignable ( <tCOMMA> asignable )* <tPTCL>
Attributes inst_leer() :
{
	Attributes toRet = new Attributes();
	Token token;
	Attributes temp = null;
}
{
	try {
		<tGET>
		<tPTOP>
		temp = asignable()
		{
			toRet.block.addBlock(temp.block);
			toRet.block.addInst(PCodeInstruction.OpCode.RD, 1);
		}
		(
			<tCOMMA>
			temp = asignable() 
			{
				toRet.block.addBlock(temp.block);
				toRet.block.addInst(PCodeInstruction.OpCode.RD, 1);
			}
		)*
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		toRet.block.encloseXMLTags("get");
		return toRet;
	}
}

//Aqui no hay nada que comprobar
//inst_saltar_linea : <tSKIPL> <tPTOP> <tPTCL>
Attributes inst_saltar_linea() :
{
	Attributes toRet = new Attributes();
}
{
	try {
		<tSKIPL>
		{
			//Para saltar la línea escribimos CR/LF
			toRet.block.addComment("CR/LF");
			toRet.block.addInst(PCodeInstruction.OpCode.STC, 13);
			toRet.block.addInst(PCodeInstruction.OpCode.WRT, 0);
			toRet.block.addInst(PCodeInstruction.OpCode.STC, 10);
			toRet.block.addInst(PCodeInstruction.OpCode.WRT, 0);
		}
		<tPTOP>
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{	
		toRet.block.encloseXMLTags("put_line");
		return toRet;
	}
}

//inst_escribir : <tPUT> <tPTOP> lista_exps <tPTCL>
Attributes inst_escribir() :
{
	ArrayList<Attributes> exps = null;
	Attributes toRet = new Attributes();
	Attributes temp = null;
}
{
	try {
		<tPUT>
		<tPTOP>
		exps = lista_exps()
		{
			for (int i = 0; i < exps.size(); i++) {
				temp = exps.get(i);
				CodeBlock put = new CodeBlock();
				//Si es invocacion a funcion el tipo FUNCTION se cambia por el tipo de retorno
				if (temp.type == Symbol.Types.FUNCTION) {
					temp.type = ((SymbolFunction)temp.simbolo).returnType;
				}
				switch (temp.type) {
					case INT:
						put.addBlock(temp.block);
						put.addComment("Escribiendo un tipo " + temp.type);
						put.addInst(PCodeInstruction.OpCode.WRT, 1);
						break;
					case CHAR:
						put.addComment("Escribiendo un tipo " + temp.type + " val: "
							+ temp.valChar);
						put.addBlock(temp.block);
						put.addInst(PCodeInstruction.OpCode.WRT, 0);
						break;
					case BOOL:
						put.addComment("Escribiendo un tipo " + temp.type + " val: "
							+ temp.valBool);
						put.addBlock(temp.block);
						put.addInst(PCodeInstruction.OpCode.WRT, 0);
						//TODO: esto no funcionará, hay que hacer 2 label y un goto para imprimir los codigos ascii de true y false
						break;
					case STRING:
						put.addComment("Escribiendo un tipo " + temp.type +
							" val: \"" + temp.valString + "\" length: " + temp.valString.length());
						put.addBlock(temp.block);
						for (int j = temp.valString.length()-1; j>=0 ; j--) {
							put.addInst(PCodeInstruction.OpCode.WRT, 0);
						}
						break;
					
					default:
						System.err.println("No se puede escribir el tipo" + exps.get(i).type);
						break;
				}
				put.encloseXMLTags("put");
				toRet.block.addBlock(put);
			}
		}
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//inst_escribir_linea : <tPUTL> <tPTOP> lista_exps <tPTCL>
Attributes inst_escribir_linea() :
{
	ArrayList<Attributes> exps;
	Attributes toRet = new Attributes();
	Attributes temp = null;
}
{
	try {
		<tPUTL>
		<tPTOP>
		exps = lista_exps()
		{
			for (int i = 0; i < exps.size(); i++) {
				temp = exps.get(i);
				CodeBlock put = new CodeBlock();
				//Si es invocacion a funcion el tipo FUNCTION se cambia por el tipo de retorno
				if (temp.type == Symbol.Types.FUNCTION) {
					temp.type = ((SymbolFunction)temp.simbolo).returnType;
				}
				switch (temp.type) {
					case INT:
						put.addBlock(temp.block);
						put.addComment("Escribiendo un tipo " + temp.type);
						put.addInst(PCodeInstruction.OpCode.WRT, 1);
						break;
					case CHAR:
						put.addComment("Escribiendo un tipo " + temp.type + " val: "
							+ temp.valChar);
						put.addBlock(temp.block);
						put.addInst(PCodeInstruction.OpCode.WRT, 0);
						break;
					//TODO añadir bool cómo antes
					case STRING:
						put.addComment("Escribiendo un tipo " + temp.type +
							" val: \"" + temp.valString + "\" length: " + temp.valString.length());
						put.addBlock(temp.block);
						for (int j = temp.valString.length()-1; j>=0 ; j--) {
							put.addInst(PCodeInstruction.OpCode.WRT, 0);
						}
						break;
					default:
						System.err.println("No se puede escribir el tipo" + exps.get(i).type);
						break;
				}
				put.encloseXMLTags("put");
				toRet.block.addBlock(put);
			}
			//Despues de todo escribimos salto de linea
			CodeBlock putL = new CodeBlock();
			//Si no hay ningún put escribimos el put vacío
			if (temp == null) {
				putL.encloseXMLTags("put");
			}
			putL.addComment("CR/LF");
			putL.addInst(PCodeInstruction.OpCode.STC, 13);
			putL.addInst(PCodeInstruction.OpCode.WRT, 0);
			putL.addInst(PCodeInstruction.OpCode.STC, 10);
			putL.addInst(PCodeInstruction.OpCode.WRT, 0);
			putL.encloseXMLTags("put_line");
			toRet.block.addBlock(putL);
		}
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//inst_invoc_proc : <tID> <tPTOP> lista_exps <tPTCL>
Attributes inst_invoc_proc() :
{
	Token funcName;
	Symbol proc;
	ArrayList<Attributes> parList = new ArrayList<Attributes>();
	ArrayList<Symbol> expectedPars;
	SymbolProcedure expFunc = null;
	Attributes toRet = new Attributes();
}
{
	try {
		funcName = <tID>
		<tPTOP>
		parList = lista_exps()
		{
			proc = st.getSymbol(funcName.image);
			if (proc.type != Symbol.Types.PROCEDURE) {
				es.deteccion("El símbolo utilizado no es un procedimiento", funcName);
			} else {
				expFunc = (SymbolProcedure) proc;
				expectedPars = expFunc.parList;
				if (expectedPars.size() != parList.size())
				{
					es.deteccion("El número de parámetros no coincide con el esperado", funcName);
				}
				for (int i = 0; i< parList.size(); i++) {
					Symbol expPar = expectedPars.get(i);
					Attributes givenPar = parList.get(i);
					if (givenPar.type != expPar.type) {
						es.deteccion("El parámetro " + i + " es " + givenPar.type + " y se esperaba: " + expPar.type, funcName);
					} else {
						//Si paso por referencia, tiene que ser asignable
						if (expPar.parClass == Symbol.ParameterClass.REF && !givenPar.referenciable) {
							es.deteccion("El parámetro " + i + " no es referenciable", funcName);
						}
						//Comprobar en caso de ser un vector, que tiene las mismas dimensiones.
						if (givenPar.type == Symbol.Types.ARRAY){
							SymbolArray expParArray = (SymbolArray) expPar;
							SymbolArray givenParArray = (SymbolArray) givenPar.simbolo;
						
							boolean sameDimensions =	expParArray.minInd == givenParArray.minInd &&
													expParArray.maxInd == givenParArray.maxInd;
							if (!sameDimensions) {
								es.deteccion("El parámetro " + i + " tiene rango: ("+ givenParArray.minInd + "," + givenParArray.maxInd + ")"
								+" y se esperaba: ("+ expParArray.minInd + "," + expParArray.maxInd + ")", funcName);
							}
						}
					}
				}
			
				//Generación de código
				for (int i = 0; i < parList.size(); i++) {
					Symbol expPar = expectedPars.get(i);
					Attributes givenPar = parList.get(i);
						
					if (expPar.parClass == Symbol.ParameterClass.REF
						&& givenPar.parClass != Symbol.ParameterClass.REF) { //Puede ser VAL o NONE
						//Hay que quitar la dereferencia, que es la última instrucción
						givenPar.block.delLastInst();
					} else if (expPar.parClass == Symbol.ParameterClass.VAL
						&& givenPar.parClass == Symbol.ParameterClass.REF) {
						//Hay que dereferenciar una vez más, para obtener el valor de la variable original
						givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
					}
					if (expPar.parClass == Symbol.ParameterClass.VAL && 
					expPar.type == Symbol.Types.ARRAY) {
						givenPar.block.addComment("Array pasado por valor");
						for (int k = 0; k < ((SymbolArray)expPar).maxInd; k++)
						{
							givenPar.block.addInst(PCodeInstruction.OpCode.SRF, st.level - givenPar.simbolo.nivel , (int)givenPar.simbolo.dir);
							givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
							givenPar.block.addInst(PCodeInstruction.OpCode.STC, k);
							givenPar.block.addInst(PCodeInstruction.OpCode.PLUS);
							givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
						}
					}
					else if (expPar.parClass == Symbol.ParameterClass.REF && 
						expPar.type == Symbol.Types.ARRAY) {
						givenPar.block.addComment("Array pasado por referencia");
						givenPar.block.addInst(PCodeInstruction.OpCode.SRF, st.level - givenPar.simbolo.nivel , (int)givenPar.simbolo.dir);
						//Esto no me hace falta, porque si lo pongo estoy escribiendo el valor
						//givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
					}
						givenPar.block.encloseXMLTags(String.format("parámetro_%d", i+1));
						toRet.block.addBlock(givenPar.block);
				}
				toRet.block.addOSFInst(cgu.memorySpaces[st.level], st.level - proc.nivel, "L"+proc.dir);
				toRet.block.encloseXMLTags("llamada_a_funcion_"+proc.name);
			}
		}
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		// añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch (SymbolNotFoundException e) {
		es.deteccion(e, token);
	}
	{
		return toRet;
	}
}

//inst_invoc_func : <tID> <tPTOP> lista_exps <tPTCL>
Attributes inst_invoc_func() :
{
	Attributes toRet = new Attributes();
	Token funcName;
	Symbol func = null;
	ArrayList<Attributes> parList = new ArrayList<Attributes>();
	ArrayList<Symbol> expectedPars;
	SymbolFunction expFunc = null;
}
{
	try {
		funcName = <tID>
		{
			func = st.getSymbol(funcName.image);
			if (func.type != Symbol.Types.FUNCTION) {
				es.deteccion(new SymbolNotFoundException(), funcName);
			}
		}
		<tPTOP>
		parList = lista_exps()
		{
			//Comprobaciones semánticas
			expFunc = (SymbolFunction) func;
			expectedPars = expFunc.parList;
			if (expectedPars.size() != parList.size())
			{
				es.deteccion("El número de parámetros no coincide con el esperado", funcName);
			}
			for (int i = 0; i< parList.size(); i++) {
				Symbol expPar = expectedPars.get(i);
				Attributes givenPar = parList.get(i);
				if (givenPar.type != expPar.type) {
					es.deteccion("El parámetro " + i + " es " + givenPar.type + " y se esperaba: " + expPar.type, funcName);
				}
				//Si paso por referencia, tiene que ser asignable
				if (expPar.parClass == Symbol.ParameterClass.REF && !givenPar.referenciable) {
					es.deteccion("El parámetro " + i + " no es referenciable", funcName);
				}
				//Comprobar en caso de ser un vector, que tiene las mismas dimensiones.
				if (givenPar.type == Symbol.Types.ARRAY){
					SymbolArray expParArray = (SymbolArray) expPar;
					SymbolArray givenParArray = (SymbolArray) givenPar.simbolo;
				
					boolean sameDimensions =	expParArray.minInd == givenParArray.minInd &&
											expParArray.maxInd == givenParArray.maxInd;
					if (!sameDimensions) {
						es.deteccion("El parámetro " + i + " tiene rango: ("+ givenParArray.minInd + "," + givenParArray.maxInd + ")"
						+" y se esperaba: ("+ expParArray.minInd + "," + expParArray.maxInd + ")", funcName);
					}
				}
			}
			
			//Generación de código
			for (int i = 0; i < parList.size(); i++) {
				Symbol expPar = expectedPars.get(i);
				Attributes givenPar = parList.get(i);
				if (expPar.parClass == Symbol.ParameterClass.REF
					&& givenPar.parClass != Symbol.ParameterClass.REF) { //Puede ser VAL o NONE
					//Hay que quitar la dereferencia, que es la última instrucción
					givenPar.block.delLastInst();
				} else if (expPar.parClass == Symbol.ParameterClass.VAL
					&& givenPar.parClass == Symbol.ParameterClass.REF) {
					//Hay que dereferenciar una vez más, para obtener el valor de la variable original
					givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
				}
				if (expPar.parClass == Symbol.ParameterClass.VAL && 
					expPar.type == Symbol.Types.ARRAY) {
					givenPar.block.addComment("Array pasado por valor");
					for (int k = 0; k < ((SymbolArray)expPar).maxInd; k++)
					{
						givenPar.block.addInst(PCodeInstruction.OpCode.SRF, st.level - givenPar.simbolo.nivel , (int)givenPar.simbolo.dir);
						givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
						givenPar.block.addInst(PCodeInstruction.OpCode.STC, k);
						givenPar.block.addInst(PCodeInstruction.OpCode.PLUS);
						givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
					}
				}
				else if (expPar.parClass == Symbol.ParameterClass.REF && 
					expPar.type == Symbol.Types.ARRAY) {
					givenPar.block.addComment("Array pasado por referencia");
					givenPar.block.addInst(PCodeInstruction.OpCode.SRF, st.level - givenPar.simbolo.nivel , (int)givenPar.simbolo.dir);
					givenPar.block.addInst(PCodeInstruction.OpCode.DRF);
				}
				givenPar.block.encloseXMLTags(String.format("parámetro_%d", i+1));
				toRet.block.addBlock(givenPar.block);
			}
			toRet.block.addOSFInst(cgu.memorySpaces[st.level], st.level - func.nivel, "L"+func.dir);
			toRet.block.encloseXMLTags("llamada_a_funcion_"+func.name);
		}
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		// añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch (SymbolNotFoundException e) {
		es.deteccion(e, token);
	}
	{
		toRet.type = expFunc.returnType;
		toRet.referenciable = false;
		toRet.simbolo = func;
		return toRet;
	}
}


//inst_asignacion : asignable <tASIG> expresion
Attributes inst_asignacion() :
{
	Attributes asig;
	Attributes expr;
	Attributes toRet = new Attributes();
}
{
	try {
		asig = asignable()
		{
			toRet.block.addBlock(asig.block);
		}
		<tASIG>
		expr = expresion()
		{
			toRet.block.addBlock(expr.block);
			//Asignar a la variable asig la expresión expr
			toRet.block.addInst(PCodeInstruction.OpCode.ASG);
			
			if (asig.type == Symbol.Types.ARRAY) {
				toRet.block.encloseXMLTags(String.format("asignación_en_componente_de_vector_%s", asig.name));	
			} else {
				toRet.block.encloseXMLTags(String.format("asignación_en_variable_simple_%s", asig.name));
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//inst_seleccion :	<tIF> expresion <tTHEN> ( instruccion )* resto_if <tEND>
Attributes inst_seleccion() :
{
	boolean hayReturn1 = false;
	boolean hayReturn2 = true;
	boolean warning = false;	//Si no hay ningún return no hay que dar warning
	Token tokenIf;
	Attributes attrIf = null;
	Attributes attrThen = new Attributes();
	Attributes attrInst = null;
	Attributes attrElse = null;
	Attributes toRet = new Attributes();
	String labelFinIf = "";
	String labelFinElse = "";
	boolean aux = false;
}
{
	try {
		tokenIf = <tIF>
		attrIf = expresion() {
			if (attrIf.type != Symbol.Types.BOOL)
				es.deteccion("El tipo de la expresion tiene que ser booleano", token);
			
			attrIf.block.encloseXMLTags("condición");
			toRet.block.addBlock(attrIf.block);
			labelFinIf = cgu.newLabel();
			//De momento no sabemos si hay else,
			//así que en caso de no haberlo se salta al fin del if
			labelFinElse = labelFinIf;
			toRet.block.addInst(PCodeInstruction.OpCode.JMF, labelFinIf);
		}
		<tTHEN>
		(
			attrInst = instruccion()
			{
				aux = attrInst.hayReturn;
				hayReturn1 |= aux;
				//En caso de que solo haya if, y haya un return, dar warning
				warning = hayReturn1;
				
				//Añadir la instrucción al bloque de instrucciones del then
				attrThen.block.addBlock(attrInst.block);
			}
		)*
		(
			attrElse = resto_if()
			{
				//Generar la etiqueta de fin de else porque hay else
				labelFinElse = cgu.newLabel();
				
				//Incluir el final del bloque then tras obtener la etiqueta de fin de else
				attrThen.block.addInst(PCodeInstruction.OpCode.JMP, labelFinElse);
				attrThen.block.encloseXMLTags("then");
				toRet.block.addBlock(attrThen.block);
				
				//Hay que poner la etiqueta de fin de if lo primero
				CodeBlock swapBlock = new CodeBlock();
				swapBlock.addLabel(labelFinIf);
				swapBlock.addBlock(attrElse.block);
				attrElse.block = swapBlock;
				attrElse.block.encloseXMLTags("else");
				toRet.block.addBlock(attrElse.block);
				
				hayReturn2 = attrElse.hayReturn;
				//Hay que dar warning si solo hay return en uno de los dos casos
				warning = (hayReturn1 && !hayReturn2) || (!hayReturn1 && hayReturn2);
			}
		)?
		<tEND>
		{
			if (attrElse != null) {
				//Añadir etiqueta de fin de else
				toRet.block.addLabel(labelFinElse);
			} else {
				//Incluir el final del bloque then sin añadir el salto a la etiqueta de fin de else
				attrThen.block.encloseXMLTags("then");
				toRet.block.addBlock(attrThen.block);
				//Incluir el labelFinElse porque no se ha añadido al principio del else
				toRet.block.addLabel(labelFinIf);
			}
			
			toRet.block.encloseXMLTags("if-then");
			
			if (warning) {
				es.warning("Es posible que el return no se ejecute", tokenIf);
			}
			toRet.hayReturn =  hayReturn1 && hayReturn2;
			return toRet;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//resto_if : <tELSE> ( instruccion )*
Attributes resto_if() :
{
	boolean hayReturn = false;
	boolean aux = false;
	Attributes toRet = new Attributes();
	Attributes temp = null;
}
{
	try {
		<tELSE>
		(
			temp = instruccion()
			{
				toRet.block.addBlock(temp.block);
				aux = temp.hayReturn;
				hayReturn |= aux;
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		toRet.hayReturn = hayReturn;
		return toRet;
	}
}

//asignable : LOOKAHEAD(2)
//				<tID> <tSQOP> expresion <tSQCL>
//			|	<tID>
//Un asignable es el nombre de una variable escalar o de un vector con un indice (que puede ser una expresion)
//
//Desde asignable tenemos que comprobar que el nombre existe, así que no haga falta mirarlo en los varios lugares donde llamamos esta funcion

Attributes asignable() :
{
	Token token;
	Attributes attr;
	Attributes toRet = new Attributes();
	Symbol s = null;
}
{
	try {
	LOOKAHEAD(3)
		token = <tID> {
			if (!st.containsSymbol(token.image)) {
				es.deteccion(new SymbolNotFoundException(), token);
			} else {
				s = st.getSymbol(token.image);
				toRet.type = s.type;
				toRet.name = s.name;
				toRet.simbolo = s;
			}
		}

		<tSQOP>
		attr = expresion() {
			if (attr.type != Symbol.Types.INT) {
				es.deteccion("Tipo de indice incorrecto, esperaba un entero", token);
			} else {
				//Código que da el resultado de la expresión
				toRet.block.addBlock(attr.block);
				
				if (genErrEjec) {
					//Para acceder a componentes específicas de vector
					SymbolArray sArr = (SymbolArray) s;
					String lblIniError = cgu.newLabel();
					String lblFinError = cgu.newLabel();
					String error = String.format("Error: Índice fuera de límites para el vector \"%s\".", s.name);
					
					//Escribir código para comprobar si el índice está dentro de rango
					toRet.block.addComment(String.format("Comprobando si el índice es válido para el vector \"%s\"", s.name));
					
					//Duplicamos el resultado para no perderlo con las comprobaciones
					toRet.block.addInst(PCodeInstruction.OpCode.DUP);
					toRet.block.addInst(PCodeInstruction.OpCode.STC, sArr.minInd);
					toRet.block.addInst(PCodeInstruction.OpCode.GTE);
					toRet.block.addInst(PCodeInstruction.OpCode.JMF, lblIniError);
					toRet.block.addInst(PCodeInstruction.OpCode.DUP);
					toRet.block.addInst(PCodeInstruction.OpCode.STC, sArr.maxInd);
					toRet.block.addInst(PCodeInstruction.OpCode.LTE);
					toRet.block.addInst(PCodeInstruction.OpCode.JMT, lblFinError);
					
					//Añadir etiqueta de inicio de error
					toRet.block.addLabel(lblIniError);
					toRet.block.addComment(String.format("Escribiendo: \"%s\"", error));
					
					//En caso de que no hayamos saltado más adelante, aquí mostramos por pantalla el error
					for (int i = 0; i < error.length(); i++) {
						toRet.block.addInst(PCodeInstruction.OpCode.STC, (int) error.charAt(i));
						toRet.block.addInst(PCodeInstruction.OpCode.WRT, 0);
					}
					//Añadir salto de línea
					toRet.block.addComment("CR/LF");
					toRet.block.addInst(PCodeInstruction.OpCode.STC, 13);
					toRet.block.addInst(PCodeInstruction.OpCode.WRT, 0);
					toRet.block.addInst(PCodeInstruction.OpCode.STC, 10);
					toRet.block.addInst(PCodeInstruction.OpCode.WRT, 0);
					
					//Salir del programa a causa del error
					toRet.block.addInst(PCodeInstruction.OpCode.LVP);
					
					//Añadir etiqueta de fin de error
					toRet.block.addLabel(lblFinError);
				}
				
				toRet.block.addComment(String.format("Dirección inicial de vector \"%s\".", s.name));
				toRet.block.addInst(PCodeInstruction.OpCode.SRF, st.level - s.nivel , (int)s.dir);

				//Hay que dereferenciar la dirección de la referencia,
				//para obtener la dirección de la variable referenciada
				if (s.parClass == Symbol.ParameterClass.REF) {
					toRet.block.addInst(PCodeInstruction.OpCode.DRF);
				}
				//Ahora que hemos obtenido la direccion de vett[0]
				//Se le suma a la dirección inicial, el índice
				toRet.block.addInst(PCodeInstruction.OpCode.PLUS);
				//Este hay que quitarlo porquè ya hemos hecho un DRF, y nos hace falta
				//La direccion de v[indice] para asignarle lo que sea
				//toRet.block.addInst(PCodeInstruction.OpCode.DRF);
			}
		}
		<tSQCL>
	|	token = <tID> {
			if (!st.containsSymbol(token.image)) {
				es.deteccion(new SymbolNotFoundException(), token);
			} else {
				s = st.getSymbol(token.image);
				toRet.type = s.type;
				toRet.name = s.name;
				toRet.simbolo = s;
				
				toRet.block.addComment(String.format("Obteniendo variable simple/parámetro \"%s\".", toRet.name));
				toRet.block.addInst(PCodeInstruction.OpCode.SRF, st.level - s.nivel , (int)s.dir);
				//Hay que dereferenciar la dirección de la referencia,
				//para obtener la dirección de la variable referenciada
				if (s.parClass == Symbol.ParameterClass.REF) {
					toRet.block.addInst(PCodeInstruction.OpCode.DRF);
				}
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return toRet;
	}
}

//inst_iteracion : <tWHIL> expresion <tDO> ( instruccion )* <tEND>
Attributes inst_iteracion() :
{
	boolean hayReturn = false;
	boolean aux = false;
	Attributes toRet = new Attributes();
	Attributes attrCond = null;
	Attributes attrDo = new Attributes();
	Attributes attrInst = null;
	String labelInicio = cgu.newLabel();
	String labelFin = cgu.newLabel();
}
{
	try {
		<tWHIL>
		attrCond = expresion()
		{
			toRet.block.addLabel(labelInicio);
			
			attrCond.block.encloseXMLTags("condición");
			toRet.block.addBlock(attrCond.block);
			toRet.block.addInst(PCodeInstruction.OpCode.JMF, labelFin);
		}
		<tDO>
		(
			attrInst = instruccion()
			{
				aux = attrInst.hayReturn;
				hayReturn |= aux;
				
				//Añadir la instrucción al bloque de instrucciones del do
				attrDo.block.addBlock(attrInst.block);
			}
		)*
		<tEND>
		{
			//Finalizar el bloque de instrucciones del while
			attrDo.block.encloseXMLTags("bloque_instrucciones_while");
			toRet.block.addBlock(attrDo.block);
			//Finalizar el while
			toRet.block.addInst(PCodeInstruction.OpCode.JMP, labelInicio);
			toRet.block.addLabel(labelFin);
			toRet.block.encloseXMLTags("while");
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		toRet.hayReturn = hayReturn;
		return toRet;
	}
}

//inst_return : <tRET> expresion
Attributes inst_return() :
{
	Attributes toRet = new Attributes();
	Attributes expr;
}
{
	try {
		<tRET>
		expr = expresion()
		{
			toRet.block.addBlock(expr.block);
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		toRet.block.addInst(PCodeInstruction.OpCode.CSF);
		toRet.block.encloseXMLTags("return");
		toRet.hayReturn = true;
		return toRet;
	}
}

//lista_exps : ( expresion ( <tCOMMA> expresion )* )?
ArrayList<Attributes> lista_exps() :
{
	ArrayList<Attributes> parList = new ArrayList<Attributes>();
	Attributes attr;
}
{
	try {
		(
			attr = expresion() { 
				parList.add(attr);
			}
			(
				<tCOMMA>
				attr = expresion() { 
				parList.add(attr);
				}
			)*
		)?
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return parList;
	}
}

//expresion : expresion_simple ( operador_relacional expresion_simple )?
Attributes expresion() :
{
	Attributes attrExpresion1;
	Symbol.Types tipo_operador = null;
	Attributes attrExpresion2 = null;
	Attributes retAttribute = new Attributes();
	retAttribute.type = Symbol.Types.BOOL;
	retAttribute.referenciable = false;
	PCodeInstruction.OpCode opRel;
}
{
	try {
		attrExpresion1 = expresion_simple()
		(
			opRel = operador_relacional()
			attrExpresion2 = expresion_simple()
			{
				if (attrExpresion2.type != attrExpresion1.type) {
					es.deteccion("Tipos incoherentes entre variables", token);
				} else {
					//Añadir código para la generación de la comparación
					retAttribute.block.addBlock(attrExpresion1.block);
					retAttribute.block.addBlock(attrExpresion2.block);
					retAttribute.block.addInst(opRel);
				}	
				return retAttribute; //Si hay operador relacional devuelve un Attributes booleano
			}
		)?
		{
			return attrExpresion1; //Si no hay operador relacional
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_relacional :	<tEQ> =
//					|	<tLT> <
//					|	<tGT> >
//					|	<tLEQ> <=
//					|	<tGEQ> >=
//					|	<tDIFF> <>
PCodeInstruction.OpCode operador_relacional() :
{
}
{
	try {
		<tEQ>
		{
			return PCodeInstruction.OpCode.EQ;
		}
	|	<tLT>
		{
			return PCodeInstruction.OpCode.LT;
		}
	|	<tGT>
		{
			return PCodeInstruction.OpCode.GT;
		}
	|	<tLEQ>
		{
			return PCodeInstruction.OpCode.LTE;
		}
	|	<tGEQ>
		{
			return PCodeInstruction.OpCode.GTE;
		}
	|	<tDIFF>
		{
			return PCodeInstruction.OpCode.NEQ;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//expresion_simple : ( <tADD> | <tSUB> )? termino ( operador_aditivo termino )*
Attributes expresion_simple() :
{
	Attributes a = new Attributes();
	Attributes a2 = new Attributes();
	Token t;
	PCodeInstruction.OpCode opSig = null;
	PCodeInstruction.OpCode opAd;
}
{
	try {
		(
			<tADD>
			{
				opSig = PCodeInstruction.OpCode.PLUS;
			}
		|	<tSUB>
			{
				opSig = PCodeInstruction.OpCode.SBT;
			}
		)?
		a = termino()
		{
			if (opSig != null) {
				if (a.type != Symbol.Types.INT) {
					es.deteccion("La variable despues de +/- tiene que ser entera", token);
				}
				a.referenciable = false;
			}
		}
		(
			opAd = operador_aditivo() {
				if ((opAd == PCodeInstruction.OpCode.OR)
					&& (a.type != Symbol.Types.BOOL)) {
					es.deteccion("Los tipos del operando y el termino no coinciden: "
						+ a.type + " vs BOOL", token);
				}
				if (a.type == Symbol.Types.ARRAY ) {
					es.deteccion("Utilizado operator aditivo con vector", token);
				}
				a.referenciable = false;
				
				//Si es una operación de resultado booleano, actualizar el tipo resultado
				if (opAd == PCodeInstruction.OpCode.OR) {
					a.type = Symbol.Types.BOOL;
				}
			}
			a2 = termino() {
				if (a2.type != a.type) {
					es.deteccion("Los tipos de los terminos de la operación aditiva no coinciden "
						+ a.type + " vs " + a2.type, token);
				}
				if (a2.type == Symbol.Types.ARRAY ) {
						es.deteccion("Suma entre vector y otra variable", token);
				}
				a.referenciable = false;
				
				//Añadir código de la adición de lo apilado anteriormente con el siguiente termino
				a.block.addBlock(a2.block);
				a.block.addInst(opAd);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		if (opSig != null) {
			a.block.addInst(opSig);
		}
		return a;
	}
}

//operador_aditivo :	<tADD>
//					|	<tSUB>
//					|	<tOR>
PCodeInstruction.OpCode operador_aditivo() :
{
}
{
	try {
		<tADD>
		{
			return PCodeInstruction.OpCode.PLUS;
		}
	|	<tSUB>
		{
			return PCodeInstruction.OpCode.SBT;
		}
	|	<tOR>
		{
			return PCodeInstruction.OpCode.OR;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//termino : factor ( operador_multiplicativo factor )*
Attributes termino() :
{
	Attributes a = null;
	PCodeInstruction.OpCode opMul;
	Attributes a2;
}
{
	try {
		a = factor()
		(
			opMul = operador_multiplicativo() {
				if ((opMul == PCodeInstruction.OpCode.AND)
					&& (a.type != Symbol.Types.BOOL)) {
					es.deteccion("Los tipos del operando y el termino no coinciden: "
						+ a.type + " vs BOOL", token);
				}
			}
			a2 = factor() {
				if (a2.type != a.type) {
					es.deteccion("Los tipos de los operandos no coinciden: " + a.type + " vs " + a2.type, token);
				}
				a.referenciable = false;
				
				//Si es una operación de resultado booleano, actualizar el tipo resultado
				if (opMul == PCodeInstruction.OpCode.AND) {
					a.type = Symbol.Types.BOOL;
				}
				
				//Añadir código de la multiplicación de lo apilado anteriormente con el siguiente termino
				a.block.addBlock(a2.block);
				a.block.addInst(opMul);
			}
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return a;
	}
}

//operador_multiplicativo :	<tMUL>
//						|	<tMOD>
//						|	<tDIV>
//						|	<tAND>
PCodeInstruction.OpCode operador_multiplicativo() :
{
}
{
	try {
		<tMUL>
		{
			return PCodeInstruction.OpCode.TMS;
		}
	|	<tMOD>
		{
			return PCodeInstruction.OpCode.MOD;
		}
	|	<tDIV>
		{
			return PCodeInstruction.OpCode.DIV;
		}
	|	<tAND>
		{
			return PCodeInstruction.OpCode.AND;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//factor :	<tNOT> factor
//		|	<tPTOP> expresion <tPTCL>
//		|	<tINT2CHAR> <tPTOP> expresion <tPTCL>
//		|	<tCHAR2INT> <tPTOP> expresion <tPTCL>
//		|	LOOKAHEAD(2)  <tID> <tPTOP> lista_exps <tPTCL> Esta es una llamada a funcion
//		|	LOOKAHEAD(2)  <tID> <tSQOP> expresion <tSQCL>  componente vector
//		|	<tID>
//		|	<tNUM>
//		|	<tCHAR>
//		|	<tSTRING>
//		|	<tTRUE>
//		|	<tFALSE>
Attributes factor() :
{
	Attributes a = new Attributes();
	Attributes temp;
	Token t;
	Symbol s = null;
	Token tempTok;
}
{
	try {
		<tNOT>
		a = factor() { 
			if (a.type != Symbol.Types.BOOL) {
				es.deteccion("El tipo de la expresión tiene que ser booleano", token);
			}
			a.referenciable = false;
			a.block.addInst(PCodeInstruction.OpCode.NGB);
		}
	|	<tPTOP>
		a = expresion()
		<tPTCL>
	|	<tITOA>
		<tPTOP>
		//A int to ascii tienes que pasarle un int
		temp = expresion()
		{
			if (temp.type != Symbol.Types.INT) {
				es.deteccion("El tipo de la expresión tiene que ser entero", token);
			}
			a.type = Symbol.Types.CHAR;
			a.referenciable = false;
		}
		<tPTCL>
	|	<tATOI>
		<tPTOP>
		//A ascii to int tienes que pasarle un char
		temp = expresion()
		{
			if (temp.type != Symbol.Types.CHAR) {
				es.deteccion("El tipo de la expresión tiene que ser caracter", token);
			}
			a.type = Symbol.Types.INT;
			a.referenciable = false;
		}
		<tPTCL>
	|	LOOKAHEAD(2) 
		a = inst_invoc_func()
	|	LOOKAHEAD(2) 
		t = <tID>	//Esto es id de vector
		{
			if (!st.containsSymbol(t.image)) {
				es.deteccion(new SymbolNotFoundException(), t);
			} else {
				s = st.getSymbol(t.image);
				if (s.type != Symbol.Types.ARRAY) {
					es.deteccion(t.image + " no es identificador de vector, es de tipo: " + s.type, t);
				}
				SymbolArray sArr = (SymbolArray) s;
				a.type = sArr.baseType;
				a.referenciable = true;
				a.name = t.image;
				a.simbolo = s;
			}
		}
		<tSQOP>
		temp = expresion() { 
			if (temp.type != Symbol.Types.INT) {
				es.deteccion("El indice de elemento de vector tiene que ser entero", t);
			}
			//Código que da el resultado de la expresión
			a.block.addBlock(temp.block);
			
			if (genErrEjec) {
				//Para acceder a componentes específicas de vector
				SymbolArray sArr = (SymbolArray) a.simbolo;
				String lblIniError = cgu.newLabel();
				String lblFinError = cgu.newLabel();
				String error = String.format("Error: Índice fuera de límites para el vector \"%s\".", a.name);
				
				//Escribir código para comprobar si el índice está dentro de rango
				a.block.addComment(String.format("Comprobando si el índice es válido para el vector \"%s\"", a.name));
				
				//Duplicamos el resultado para no perderlo con las comprobaciones
				a.block.addInst(PCodeInstruction.OpCode.DUP);
				a.block.addInst(PCodeInstruction.OpCode.STC, sArr.minInd);
				a.block.addInst(PCodeInstruction.OpCode.GTE);
				a.block.addInst(PCodeInstruction.OpCode.JMF, lblIniError);
				a.block.addInst(PCodeInstruction.OpCode.DUP);
				a.block.addInst(PCodeInstruction.OpCode.STC, sArr.maxInd);
				a.block.addInst(PCodeInstruction.OpCode.LTE);
				a.block.addInst(PCodeInstruction.OpCode.JMT, lblFinError);
				
				//Añadir etiqueta de inicio de error
				a.block.addLabel(lblIniError);
				a.block.addComment(String.format("Escribiendo: \"%s\"", error));
				
				//En caso de que no hayamos saltado más adelante, aquí mostramos por pantalla el error
				for (int i = 0; i < error.length(); i++) {
					a.block.addInst(PCodeInstruction.OpCode.STC, (int) error.charAt(i));
					a.block.addInst(PCodeInstruction.OpCode.WRT, 0);
				}
				//Añadir salto de línea
				a.block.addComment("CR/LF");
				a.block.addInst(PCodeInstruction.OpCode.STC, 13);
				a.block.addInst(PCodeInstruction.OpCode.WRT, 0);
				a.block.addInst(PCodeInstruction.OpCode.STC, 10);
				a.block.addInst(PCodeInstruction.OpCode.WRT, 0);
				
				//Salir del programa a causa del error
				a.block.addInst(PCodeInstruction.OpCode.LVP);
				
				//Añadir etiqueta de fin de error
				a.block.addLabel(lblFinError);
			}
			
			a.block.addComment(String.format("Dirección inicial de vector \"%s\".", a.name));
			a.block.addInst(PCodeInstruction.OpCode.SRF, st.level - a.simbolo.nivel , (int)a.simbolo.dir);
			//Se el array que estamos utilizando es por referencia, me hace falta este
			if (s.parClass == Symbol.ParameterClass.REF) {
				a.block.addInst(PCodeInstruction.OpCode.DRF);
			}
			//Se le suma a la dirección inicial, el índice
			a.block.addInst(PCodeInstruction.OpCode.PLUS);
			//Este segundo DRF se come la direccion y pone el valor
			a.block.addInst(PCodeInstruction.OpCode.DRF);
			
			a.block.encloseXMLTags(String.format("componente_de_vector_%s", a.name));
		}
		<tSQCL>
	|	t = <tID>
		{
			if (!st.containsSymbol(t.image)) {
				es.deteccion(new SymbolNotFoundException(), t);
			} else {
				s = st.getSymbol(t.image);
				if (s.type == Symbol.Types.FUNCTION || s.type == Symbol.Types.PROCEDURE) {
					es.deteccion(t.image + " no puede ser utilizado como variable simple", t);
				}
				a.type = s.type;
				a.referenciable = true;
				a.name = t.image;
				a.simbolo = s;
				a.block.addComment(String.format("Variable simple/parámetro \"%s\".", a.name));
				if (s.type != Symbol.Types.ARRAY) {
					a.block.addInst(PCodeInstruction.OpCode.SRF, st.level - s.nivel , (int)s.dir);
					a.block.addInst(PCodeInstruction.OpCode.DRF);
					if (s.parClass == Symbol.ParameterClass.REF) {
						a.block.addInst(PCodeInstruction.OpCode.DRF);
					}
				} else {
					a.block.addComment("Encontrado identificador de array en una expresion, el còdigo se generarà luego");
				}
				
				//Suponemos que queremos siempre el valor de la variable.
				//En caso de no ser lo que queramos podemos eliminar el DRF más adelante. 
				//Para ello:
				//si es una referencia, hay que dereferenciar la dirección de
				//la variable referenciada, para obtener el valor de la variable original.
			}
		}
	|	tempTok = <tNUM>
		{
			a.type = Symbol.Types.INT;
			a.referenciable = false;
			a.valInt = Integer.parseInt(tempTok.image);
			a.block.addInst(PCodeInstruction.OpCode.STC, (int) a.valInt);
		}
	|	tempTok = <tCHAR>
		{
			a.type = Symbol.Types.CHAR;
			a.referenciable = false;
			a.valChar = tempTok.image.charAt(1);
			a.block.addInst(PCodeInstruction.OpCode.STC, (int) a.valChar);
		}
	|	tempTok = <tSTRING>
		{
			a.type = Symbol.Types.STRING;
			a.referenciable = false;
			a.valString = tempTok.image.substring(1, tempTok.image.length()-1);
			for (int i = a.valString.length()-1; i>=0 ;i--) {
				a.block.addInst(PCodeInstruction.OpCode.STC, (int) a.valString.charAt(i));
			}
		}
	|	<tTRUE>
		{
			a.type = Symbol.Types.BOOL;
			a.referenciable = false;
			a.valBool = true;
			a.block.addInst(PCodeInstruction.OpCode.STC, 1);
		}
	|	<tFALSE>
		{
			a.type = Symbol.Types.BOOL;
			a.referenciable = false;
			a.valBool = false;
			a.block.addInst(PCodeInstruction.OpCode.STC, 0);
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		conjSinc.add(tSQCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	{
		return a;
	}
}

JAVACODE //------------------------------------ 
//Informa sobre la excepción, y calcula el conjunto de tokens esperados Set infoParseException(ParseException e) {
Set<Integer> infoParseException(ParseException e) {
    Set<Integer> esperados = new HashSet<Integer>(); 
    System.err.println("ERROR_SINT: ('" + e.currentToken.next.image + ", " + e.currentToken.next.beginLine
        + "," + e.currentToken.next.beginColumn + ")");
    System.err.println("Se esperaba uno de los siguientes tokens:");
    for(int i = 0; i<e.expectedTokenSequences.length; i++) {
        esperados.add(e.expectedTokenSequences[i][0]);
        System.err.println("\t" + adac_4Constants.tokenImage[e.expectedTokenSequences[i][0]]);
    }
    return esperados;
}

JAVACODE //--------- 
void recuperacionPanico(Token tInesperado, Set <Integer> conjSinc) {
    // System.err.println(sep); 
    System.err.println("----> Recupero en modo pánico: "
        + "\n----> saltando todo hasta token de conjunto de sincronización"); 
    System.err.println("Lexema inesperado: " + tInesperado.image);
    Token t = getNextToken();
    while (!conjSinc.contains(t. kind) && t.kind != EOF){ 
        System.err.println("Descartando token ("
        + adac_4Constants.tokenImage[t.kind]
        + "," + t.image + ")"); t = getNextToken();
    }
}