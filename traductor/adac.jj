//*****************************************************************
// File:   adac.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//		   Para ejecutar el jar: java -jar ruta_jar < ruta_prog_prueba
//*****************************************************************

options {
  // IGNORE_CASE = false;
  // COMMON_TOKEN_ACTION = false;
  DEBUG_PARSER = false;
}

PARSER_BEGIN(adac)
package traductor;
import java.util.Set;
import java.util.HashSet;
import lib.symbolTable.*;
import lib.attributes.Attributes;
import lib.symbolTable.exceptions.*;
import java.util.ArrayList;

public class adac {

	static SymbolTable st = new SymbolTable();

	private static void initSymbolTable() {
		boolean b;
		String[] palsRes = {
			"procedure", "function", "val", "ref", "integer", "character", "boolean", "is", "begin", "end",
			"if", "else","while", "then", "return", "mod", "div", "true", "false", "not", "and", "function",
			"get", "char2int", "int2char", "skip_line", "put", "put_line"
		};

		st.insertReservedWords(palsRes);
	}

    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL

TOKEN_MGR_DECLS : 
{
	static void printToken (Token t, String s) {
		System.out.printf("(%d, %d): \"%s\" %s\n", t.beginLine,
		t.beginColumn, t.image, s );
	}
}

TOKEN :
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #NUM : (<DIGIT>)+ >
|	< #WORD: ["a"-"z","A"-"Z"](~[" ","\t","\n","\r","0"-"9"])*>
}

SKIP :
{
	
	< " " | "\t" | "\r" | "\n" >	// Espacios en blanco
|	< "--"(~["\n", "\r"])* >				// Comentarios
}

TOKEN :
{
	< tCHAR: "'" (~["\n","\r","'"]) "'" >
|	< tSTRING: "\"" (~["\n","\r", "\""] | "\"\"")* "\"" >
|	< tNUM: <NUM> >
|	< tPROC: "procedure" >
|	< tIS: "is" >
| 	< tBEGIN: "begin" >
|	< tEND: "end" >
|	< tRET: "return" >
|	< tBOOL: "boolean" >
|	< tCHDECL: "character" >
|   < tINT:  "integer" >
|   < tNOT:  "not" >
|   < tOR:  "or" >
|   < tAND:  "and" >
|   < tIF:  "if" >
|   < tTHEN:  "then" >
|   < tELSE:  "else" >
|   < tWHIL:  "while" >
|   < tDO:  "do" >
|	< tCOMMA:  "," >
|	< tSCOL:  ";" >
|	< tPTOP:  "(" >
|	< tPTCL:  ")" >
|	< tSQOP:  "[" >
|	< tSQCL:  "]" >
|	< tSQUOT:  "'" >
|	< tDQUOT:  "\"" >
|   < tASIG:  ":=" >
|	< tADD:  "+" >
|	< tSUB:  "-" >
|	< tMUL:  "*" >
|	< tDIV:  "div" >
|	< tMOD:  "mod" >
|	< tGT:  ">" >
|	< tLT:  "<" >
|	< tEQ:  "=" >
|	< tGEQ:  ">=" >
|	< tLEQ:  "<=" >
|	< tDIFF:  "<>" >
|	< tTRUE:  "true" >
|	< tFALSE:  "false" >
|	< tATOI:  "char2int" >
|	< tITOA:  "int2char" >
|	< tGET:  "get" >
|	< tSKIPL:  "skip_line" >
|	< tPUT:  "put" >
|	< tPUTL:  "put_line" >
|	< tFUNC: "function" >
|	< tVAL: "val" >
|	< tREF: "ref" >
|	< tID: <LETTER> ( ("_")? (<DIGIT> | <LETTER>) )* >
}
SPECIAL_TOKEN:
{
	< ~[] >
		{
			System.out.print("LEXICAL ERROR: ");
			System.out.printf("(%d, %d): unrecognized symbol: %s", matchedToken.beginLine,
			matchedToken.beginColumn, matchedToken.image );
		}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S () : 
{
	Token t1 = new Token();
}
{
	try {
		<tPROC>
		t1 = <tID>
		<tIS>
		{
			SymbolProcedure s = new SymbolProcedure(t1.image, new ArrayList<Symbol>());
			st.insertSymbol(s);
		}
		declaracion_variables()
		declaracion_procs_funcs()
		bloque_sentencias(t1.image, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED)
		<EOF>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
}

//declaracion_variables : ( declaracion <tSCOL> )*
void declaracion_variables() :
{
	
}
{
	try {
		(
			declaracion()
			<tSCOL>
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion : tipo_variable lista_vars
void declaracion() :
{
	Symbol.Types type;
}
{
	try {
		type = tipo_variable()
		lista_vars(type)
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

// tipo_variable : <tINT> | <tCHDECL> | <tBOOL>
Symbol.Types tipo_variable() :
{
	
}
{
	try {
		<tINT>
		{
			return Symbol.Types.INT;
		}
	|	<tCHDECL>
		{
			return Symbol.Types.CHAR;
		}
	|	<tBOOL>
		{
			return Symbol.Types.BOOL;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//lista_vars : variable ( <tCOMMA> variable )*
void lista_vars(Symbol.Types type) :
{
	
}
{
	try {
		variable(type)
		(
			<tCOMMA>
			variable(type)
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//variable : LOOKAHEAD(2)
//				<tID> <tACOR> <tCONST_INT> <tCCOR>
//			|	<tID>
void variable(Symbol.Types type) :
{
	Token t1;
	Token t2;
}
{
	try {
		LOOKAHEAD(2)
		t1 = <tID>
		<tSQOP>
		t2 = <tNUM>
		<tSQCL>
		{
			try {
				SymbolArray sArr = new SymbolArray(t1.image, Integer.parseInt(t2.image), type);
				st.insertSymbol(sArr);
			} catch(AlreadyDefinedSymbolException e) {
				System.err.println("Error: " + t1.image + " ya está declarado");
			}
		}
	|	t1 = <tID>
		{
			try {
				switch (type) {
					case INT : 
						SymbolInt sInt = new SymbolInt(t1.image);
						st.insertSymbol(sInt);
						break;
						
					case CHAR : 
						SymbolChar sChar = new SymbolChar(t1.image);
						st.insertSymbol(sChar);
						break;
						
					case BOOL :
						SymbolBool sBool = new SymbolBool(t1.image);
						st.insertSymbol(sBool);
						break;
					default: System.err.println("Error: " + type + " no es un tipo válido");
				}
			} catch(AlreadyDefinedSymbolException e) {
				System.err.println("Error: " + t1.image + " ya está declarado");
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_procs_funcs : ( declaracion_proc_func )*
void declaracion_procs_funcs() :
{
	
}
{
	try {
		(
			declaracion_proc_func()
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_proc_func :	declaracion_proceso
//						|	declaracion_funcion
void declaracion_proc_func() :
{
	
}
{
	try {
		declaracion_proceso()
	|	declaracion_funcion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_proceso : cabecera_proceso declaracion_variables declaracion_procs_funcs bloque_sentencias
void declaracion_proceso() :
{
	String nom;
}
{
	try {
		nom = cabecera_proceso()
		declaracion_variables()
		declaracion_procs_funcs()
		bloque_sentencias(nom, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED)
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//cabecera_proceso : <tPROC> <tID> ( decs_parametros )? <tIS>
String cabecera_proceso() :
{
	Token t1 = new Token();
	//TODO Aqui nos cogemos un ArrayList<Symbol>, pero creo sería mejor cojer un ArrayList<Symbol.Type>, así que
	//cuando en la invocacion funcion cogemos las expresiones parametros podremos hacer una comparación más sencilla
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tPROC>
		t1 = <tID>
		(
			//Todo
			//Aquí tenemos 
			parList = decs_parametros()
		)?
		<tIS>
		{
			SymbolProcedure s = new SymbolProcedure(t1.image, parList);
			st.insertSymbol(s);
			st.insertBlock();
			for (Symbol par : parList) {
				st.insertSymbol(par);
			}
			return t1.image;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
}



//declaracion_funcion : cabecera_funcion declaracion_variables declaracion_procs_funcs bloque_sentencias
void declaracion_funcion() :
{
	Attributes nomYTipo;
}
{
	try {
		nomYTipo = cabecera_funcion()
		declaracion_variables()
		declaracion_procs_funcs()
		bloque_sentencias(nomYTipo.valString, Symbol.Types.FUNCTION, nomYTipo.type)
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//cabecera_funcion : <tFUNC> tipo_variable <tID> ( decs_parametros )? <tIS>
Attributes cabecera_funcion() :
{
	Attributes nomYTipo = new Attributes();
	Token t1 = new Token();
	Symbol.Types type;
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tFUNC>
		type = tipo_variable()
		t1 = <tID>
		(
			parList = decs_parametros()
		)?
		<tIS>
		{
			SymbolFunction s = new SymbolFunction(t1.image, parList, type);
			st.insertSymbol(s);
			st.insertBlock();
			for (Symbol par : parList) {
				st.insertSymbol(par);
			}
			nomYTipo.type = type;
			nomYTipo.valString = t1.image;
			return nomYTipo;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch(AlreadyDefinedSymbolException e) {
		System.err.println("Error: " + t1.image + " ya está declarado");
	}
}

//bloque_sentencias : <tBEGIN> ( instruccion )* <tEND>
void bloque_sentencias(String nom, Symbol.Types proc_or_func, Symbol.Types retType) :
{
	boolean hayReturn = false;
	boolean aux = false;
}
{
	try {
		<tBEGIN>
		{
			System.err.println("***********************");
			System.err.println("Procesando " + nom);
			System.err.println("***********************");
		}
		(
			aux = instruccion()
			{
				hayReturn |= aux;
			}
		)*
		<tEND>
		{
			if (proc_or_func == Symbol.Types.FUNCTION && !hayReturn) {
				System.err.println("Error: No hay return en la función");
			}
			System.err.println(st.toString());
			st.removeBlock();
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//decs_parametros : <tPTOP> ( dec_parametros ( <tSCOL> dec_parametros )* )? <tPTCL>
ArrayList<Symbol> decs_parametros() :
{
	ArrayList<Symbol> partialList = new ArrayList<Symbol>();
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		<tPTOP>
		(
			partialList = dec_parametros()
			(
				<tSCOL>
				{
					parList.addAll(partialList);
				}
				partialList = dec_parametros()
			)*
		)?
		<tPTCL>
		{
			parList.addAll(partialList);
			return parList;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//dec_parametros : clase_parametros tipo_variable id_or_array ( <tCOMMA> id_or_array )*
ArrayList<Symbol> dec_parametros() :
{
	Symbol.ParameterClass parClass = Symbol.ParameterClass.NONE;
	Symbol.Types type;
	Symbol par;
	ArrayList<Symbol> parList = new ArrayList<Symbol>();
}
{
	try {
		parClass = clase_parametros()
		type = tipo_variable()
		par = id_or_array(type)
		{
			par.parClass = parClass;
			parList.add(par);
		}
		(
			<tCOMMA>
			par = id_or_array(type)
			{
				par.parClass = parClass;
				parList.add(par);
			}
		)*
		{
			return parList;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//id_or_array : LOOKAHEAD(2)
//					<tID> <tSQOP> <tNUM> <tSQCL>
//				|	<tID>
Symbol id_or_array(Symbol.Types type) :
{
	Token t1;
	Token t2;
}
{
	try {
		LOOKAHEAD(2)
		t1 = <tID>
		<tSQOP>
		t2 = <tNUM> //TODO aquí prodría ser expresion?
		<tSQCL>
		{
			return new SymbolArray(t1.image, Integer.parseInt(t2.image), type);
		}
	|	t1 = <tID>
		{
			switch (type) {
				case INT : 
					return new SymbolInt(t1.image);
					break;
					
				case CHAR : 
					return new SymbolChar(t1.image);
					break;
					
				case BOOL :
					return new SymbolBool(t1.image);
					break;
				default: System.err.println("Error: " + type + " no es un tipo válido");
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//clase_parametros:	<tREF>
//				|	<tVAL>
Symbol.ParameterClass clase_parametros() :
{
	
}
{
	try {
		<tREF>
		{
			return Symbol.ParameterClass.REF;
		}
	|	<tVAL>
		{
			return Symbol.ParameterClass.VAL;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tIS);
		conjSinc.add(tPTCL);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//instruccion : 	inst_leer <tSCOL>
//				|	inst_saltar_linea <tSCOL> 
//				|	inst_escribir <tSCOL> 
//				|	inst_escribir_linea <tSCOL> 
//				|LOOKAHEAD(2)
//					inst_invoc_proc <tSCOL> 
//				|	inst_asignacion <tSCOL> 
//				|	inst_seleccion
//				|	inst_iteracion
//				|	inst_return <tSCOL>
boolean instruccion() :
{
	boolean hayReturn = false;
}
{
	try {
		inst_leer()
		<tSCOL> { return false; }
	|	inst_saltar_linea()
		<tSCOL> { return false; }
	|	inst_escribir()
		<tSCOL> { return false; }
	|	inst_escribir_linea() 
		<tSCOL> { return false; }
	|LOOKAHEAD(2)
		inst_invoc_proc()
		<tSCOL> { return false; }
	|	inst_asignacion()
		<tSCOL> { return false; }
	|	hayReturn = inst_seleccion() { return hayReturn; }
	|	hayReturn = inst_iteracion() { return hayReturn; }
	|	inst_return()
		<tSCOL> { return true; }
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_leer : <tGET> <tPTOP> asignable ( <tCOMMA> asignable )* <tPTCL>
void inst_leer() :
{
	Token var;
}
{
	try {
		<tGET>
		<tPTOP>
		asignable()
		(
			<tCOMMA>
			asignable()
		)*
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//Aqui no hay nada que comprobar
//inst_saltar_linea : <tSKIPL> <tPTOP> <tPTCL>
void inst_saltar_linea() :
{
	
}
{
	try {
		<tSKIPL>
		<tPTOP>
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_escribir : <tPUT> <tPTOP> lista_exps <tPTCL>
void inst_escribir() :
{
	
}
{
	try {
		<tPUT>
		<tPTOP>
		lista_exps()
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_escribir_linea : <tPUTL> <tPTOP> lista_exps <tPTCL>
void inst_escribir_linea() :
{
	
}
{
	try {
		<tPUTL>
		<tPTOP>
		lista_exps()
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_invoc_proc : <tID> <tPTOP> lista_exps <tPTCL>
void inst_invoc_proc() :
{
	
}
{
	try {
		<tID>
		<tPTOP>
		lista_exps()
		<tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		// añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_asignacion : asignable <tASIG> expresion
void inst_asignacion() :
{
	
}
{
	try {
		asignable()
		<tASIG>
		expresion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_seleccion :	<tIF> expresion <tTHEN> ( instruccion )* resto_if <tEND>
boolean inst_seleccion() :
{
	boolean hayReturn1 = false;
	boolean hayReturn2 = false;
	boolean aux = false;
	Symbol.Types tipo;
}
{
	try {
		<tIF>
		tipo = expresion() {
			if (tipo != Types.BOOL)
				//TODO: tipo incorrecto
		}
		<tTHEN>
		(
			aux = instruccion()
			{
				hayReturn1 |= aux;
			}
		)*
		(
			aux = resto_if()
			{
				hayReturn2 |= aux;
			}
		)?
		<tEND>
		{
			return hayReturn1 && hayReturn2;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//resto_if : <tELSE> ( instruccion )*
boolean resto_if() :
{
	boolean hayReturn = false;
	boolean aux = false;
}
{
	try {
		<tELSE>
		(
			aux = instruccion()
			{
				hayReturn |= aux;
			}
		)*
		{
			return hayReturn;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//asignable : LOOKAHEAD(2)
//				<tID> <tSQOP> expresion <tSQCL>
//			|	<tID>
//Un asignable es el nombre de una variable escalar o de un array con un indice (que puede ser una expresion)
//
//Desde asignable tenemos que comprobar que el nombre existe, así que no haga falta mirarlo en los varios lugares donde llamamos esta funcion

void asignable() :
{
	Token var
}
{
	try {
	LOOKAHEAD(3)
		var = <tID> {
			if (!st.isReservedWord(var.image)) {
				throw new SymbolNotFoundException();
			}
		}
		<tSQOP>
		expresion() //esta tiene que ser de tipo intero
		<tSQCL>
	|	var = <tID> {
			if (!st.isReservedWord(var.image)) {
				throw new SymbolNotFoundException();
			}
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	} catch (SymbolNotFoundException e) {
		System.Out.Println("Simbolo no encontrado en " + e.line + e.column)
		//
	}
}

//inst_iteracion : <tWHIL> expresion <tDO> ( instruccion )* <tEND>
boolean inst_iteracion() :
{
	boolean hayReturn = false;
	boolean aux = false;
}
{
	try {
		<tWHIL>
		expresion()
		<tDO>
		(
			aux = instruccion()
			{
				hayReturn |= aux;
			}
		)*
		<tEND>
		{
			return hayReturn;
		}
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_return : <tRET> expresion
void inst_return() :
{
	
}
{
	try {
		<tRET>
		expresion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//lista_exps : ( expresion ( <tCOMMA> expresion )* )?
ArrayList<Symbol> lista_exps() :
{
	ArrayList<Symbol.Types> parList
}
{
	try {
		(
			expresion()
			(
				<tCOMMA>
				expresion()
			)*
		)?
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//expresion : expresion_simple ( operador_relacional expresion_simple )?
Symbol.Types expresion() :
{
	Symbol.Types tipoExpresion;
}
{
	try {
		tipoExpresion = expresion_simple()
		(
			if (operador_relacional() != tipoExpresion)
				//throw exc
			if (expresion_simple() != tipoExpresion)
				//throw exc
		)?
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_relacional :	<tEQ>
//					|	<tLT>
//					|	<tGT>
//					|	<tLEQ>
//					|	<tGEQ>
//					|	<tDIFF>
void operador_relacional() :
{
	
}
{
	//Todo esto seguro es bool, no creo que haga falta añadirlo
	try {
		<tEQ>
	|	<tLT>
	|	<tGT>
	|	<tLEQ>
	|	<tGEQ>
	|	<tDIFF>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//expresion_simple : ( <tADD> | <tSUB> )? termino ( operador_aditivo termino )*
Symbol.Types expresion_simple() :
{
	Symbol.Types toRet = Symbol.Types.UNDEFINED;
	Symbol.Types temp;
}
{
	try {
		(
			<tADD> 	temp = Symbol.Types.INT
		|	<tSUB>	temp = Symbol.Types.INT
		)?
		toRet = termino()
		if (temp!= Symbol.Types.UNDEFINED && temp!=toRet)
			//throw exc 
		(
			if (operador_aditivo() != toRet)
				throw exc
			if (termino() != toRet)
				throw exc
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_aditivo :	<tADD>
//					|	<tSUB>
//					|	<tOR>
Symbol.Types operador_aditivo() :
{
	
}
{
	try {
		<tADD>
	|	<tSUB>
	|	<tOR>	return Symbol.Types.BOOL
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	return Symbol.Types.INT
}

//termino : factor ( operador_multiplicativo factor )*
Symbol.Types termino() :
{
	Symbol.Types toRet
}
{
	try {
		toRet = factor()
		(
			if (operador_multiplicativo()!=toRet)
				//throw exc
			if (factor()!=toRet)
				//throw exc
		)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_multiplicativo :	<tMUL>
//						|	<tMOD>
//						|	<tDIV>
//						|	<tAND>
Symbol.Types operador_multiplicativo() :
{
	
}
{
	try {
		<tMUL>
	|	<tMOD>
	|	<tDIV>
	|	<tAND>  return Symbol.Types.BOOL
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	return Symbol.Types.INT
}

//factor :	<tNOT> factor
//		|	<tPTOP> expresion <tPTCL>
//		|	<tINT2CHAR> <tPTOP> expresion <tPTCL>
//		|	<tCHAR2INT> <tPTOP> expresion <tPTCL>
//		|	LOOKAHEAD(2)  <tID> <tPTOP> lista_exps <tPTCL> Esta es una llamada a funcion
//		|	LOOKAHEAD(2)  <tID> <tSQOP> expresion <tSQCL>  Igualmente
//		|	<tID>
//		|	<tNUM>
//		|	<tCHAR>
//		|	<tSTRING>
//		|	<tTRUE>
//		|	<tFALSE>
Symbol.Types factor() :
{
	Token t;
	Symbol.Types toRet = null;
}
{
	try {
		<tNOT>
			if (factor() == Symbol.Types.INT)
				//Throw exc...
			toRet = Symbol.Types.BOOL
	|	<tPTOP>
		toRet = expresion()
		<tPTCL>
	|	<tITOA>//Aqui es int2Char...el tipo es char entonces? Y porque un char es un factor?
		<tPTOP>
		if (expresion()!= Symbol.Types.INT)
				//Throw exc...
				toRet= Symbol.Types.CHAR
		<tPTCL>
	|	<tATOI>
		<tPTOP>
		if (expresion()!= Symbol.Types.CHAR)
				//Throw exc...
				toRet= Symbol.Types.INT
		<tPTCL>
	|	LOOKAHEAD(2) 
		<tID>
		<tPTOP>
		//TODO no entiendo que es esto
		lista_exps()
		<tPTCL>
	|	LOOKAHEAD(2) 
		t = <tID>
		<tSQOP>
		if (expresion()!= Symbol.Types.INT)
				//Throw exc...
		<tSQCL>
	|	t = <tID>
	|	<tNUM> toRet = Symbol.Types.INT
	|	<tCHAR> toRet = Symbol.Types.CHAR
	|	<tSTRING> toRet = Symbol.Types.STRING
	|	<tTRUE> toRet = Symbol.Types.BOOL
	|	<tFALSE> toRet = Symbol.Types.BOOL

	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tEND);
		conjSinc.add(tSCOL);
		conjSinc.add(tPTCL);
		conjSinc.add(tCOMMA);
		conjSinc.add(tSQCL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
	return toRet
}

JAVACODE //------------------------------------ 
//Informa sobre la excepción, y calcula el conjunto de tokens esperados Set infoParseException(ParseException e) {
Set<Integer> infoParseException(ParseException e) {
    Set<Integer> esperados = new HashSet<Integer>(); 
    System.err.println("ERROR_SINT: ('" + e.currentToken.next.image + ", " + e.currentToken.next.beginLine
        + "," + e.currentToken.next.beginColumn + ")");
    System.err.println("Se esperaba uno de los siguientes tokens:");
    for(int i = 0; i<e.expectedTokenSequences.length; i++) {
        esperados.add(e.expectedTokenSequences[i][0]);
        System.err.println("\t" + adacConstants.tokenImage[e.expectedTokenSequences[i][0]]);
    }
    return esperados;
}

JAVACODE //--------- 
void recuperacionPanico(Token tInesperado, Set <Integer> conjSinc) {
    // System.err.println(sep); 
    System.err.println("----> Recupero en modo pánico: "
        + "\n----> saltando todo hasta token de conjunto de sincronización"); 
    System.err.println("Lexema inesperado: " + tInesperado.image);
    Token t = getNextToken();
    while (!conjSinc.contains(t. kind) && t.kind != EOF){ 
        System.err.println("Descartando token ("
        + adacConstants.tokenImage[t.kind]
        + "," + t.image + ")"); t = getNextToken();
    }
}