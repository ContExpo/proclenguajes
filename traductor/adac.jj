//*****************************************************************
// File:   adac.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

// options {
//   IGNORE_CASE = false;
//   COMMON_TOKEN_ACTION = false;
//   ...
// }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
//------------ descripción del AL

TOKEN_MGR_DECLS : 
{
	static void printToken (Token t, String s) {
		/*System.out.printf("(%d, %d): \"%s\" %s\n", t.beginLine,
		t.beginColumn, t.image, s );*/
	}
}

TOKEN :
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #NUM : (<DIGIT>)+ >
|	< #WORD: ["a"-"z","A"-"Z"](~[" ","\t","\n","\r","0"-"9"])*>
}

SKIP :
{
	
	< " " | "\t" | "\r" | "\n" >	// Espacios en blanco
|	< "--"(~["\n", "\r"])* >				// Comentarios
}

TOKEN :
{
	< tCHAR: "'" (~["\n","\r","'"]) "'" >
		{
			printToken(matchedToken, "character");
		}
|	< tSTRING: "\"" (~["\n","\r", "\""] | "\"\"")* "\"" >
		{
			printToken(matchedToken, "string");
		}
|	< tNUM: <NUM> >
		{
			printToken(matchedToken, "number");
		}
|	< tPROC: "procedure" >
		{
			printToken(matchedToken, "declarator");
		}	
|	< tIS: "is" >
		{
			printToken(matchedToken, "statement");
		}	
| 	< tBEGIN: "begin" >
 		{
			printToken(matchedToken, "statement");
		}
|	< tEND: "end" >
		{
			printToken(matchedToken, "statement");
		}
|	< tRET: "return" >
		{
			printToken(matchedToken, "statement");
		}
|	< tBOOL: "boolean" >
		{
			printToken(matchedToken, "declarator");
		}
|	< tCHDECL: "character" >
		{
			printToken(matchedToken, "declarator");
		}
|   < tINT:  "integer" >
		{
			printToken(matchedToken, "declarator");
		}
|   < tNOT:  "not" >
		{
			printToken(matchedToken, "logical operator");
		}
|   < tOR:  "or" >
		{
			printToken(matchedToken, "logical operator");
		}
|   < tAND:  "and" >
		{
			printToken(matchedToken, "logical operator");
		}
|   < tIF:  "if" >
		{
			printToken(matchedToken, "statement");
		}
|   < tTHEN:  "then" >
		{
			printToken(matchedToken, "statement");
		}
|   < tELSE:  "else" >
		{
			printToken(matchedToken, "statement");
		}
		
|   < tWHIL:  "while" >
		{
			printToken(matchedToken, "statement");
		}
|   < tDO:  "do" >
		{
			printToken(matchedToken, "statement");
		}
|	< tCOMMA:  "," >
		{
			printToken(matchedToken, "separator ");
		}
|	< tSCOL:  ";" >
		{
			printToken(matchedToken, "separator ");
		}
|	< tPTOP:  "(" >
		{
			printToken(matchedToken, "open bracket separator");
		}
|	< tPTCL:  ")" >
		{
			printToken(matchedToken, "closed bracket separator");
		}
|	< tSQOP:  "[" >
		{
			printToken(matchedToken, "open square bracket separator");
		}
|	< tSQCL:  "]" >
		{
			printToken(matchedToken, "closed square bracket separator");
		}
|	< tSQUOT:  "'" >
		{
			printToken(matchedToken, "separator");
		}
|	< tDQUOT:  "\"" >
		{
			printToken(matchedToken, "separator");
		}
|   < tASIG:  ":=" >
		{
			printToken(matchedToken, "assign operator");
		}
|	< tADD:  "+" >
		{
			printToken(matchedToken, "addition operator");
		}
|	< tSUB:  "-" >
		{
			printToken(matchedToken, "substraction operator");
		}
|	< tMUL:  "*" >
		{
			printToken(matchedToken, "multiplication operator");
		}
|	< tDIV:  "div" >
		{
			printToken(matchedToken, "division operator");
		}
|	< tMOD:  "mod" >
		{
			printToken(matchedToken, "modulus operator");
		}
|	< tGT:  ">" >
		{
			printToken(matchedToken, "greater than logical operator");
		}
|	< tLT:  "<" >
		{
			printToken(matchedToken, "lower than logical operator");
		}
|	< tEQ:  "=" >
		{
			printToken(matchedToken, "equality logical operator");
		}
|	< tGEQ:  ">=" >
		{
			printToken(matchedToken, "greater or equal to logical operator");
		}
|	< tLEQ:  "<=" >
		{
			printToken(matchedToken, "lower or equal to logical operator");
		}
|	< tDIFF:  "<>" >
		{
			printToken(matchedToken, "inequality logical operator");
		}
|	< tTRUE:  "true" >
		{
			printToken(matchedToken, "constant logical value");
		}
|	< tFALSE:  "false" >
		{
			printToken(matchedToken, "constant logical value");
		}
|	< tATOI:  "char2int" >
		{
			printToken(matchedToken, "internal function");
		}
|	< tITOA:  "int2char" >
		{
			printToken(matchedToken, "internal function");
		}
|	< tGET:  "get" >
		{
			printToken(matchedToken, "internal function");
		}
|	< tPUT:  "put" >
		{
			printToken(matchedToken, "internal function");
		}
|	< tPUTL:  "put_line" >
		{
			printToken(matchedToken, "internal function");
		}
|	< tFUNC: "function" >
		{
			printToken(matchedToken, "declarator");
		}
|	< tVAL: "val" >
		{
			printToken(matchedToken, "declarator");
		}		
|	< tREF: "ref" >
		{
			printToken(matchedToken, "declarator");
		}		
|	< tID: <LETTER> ( ("_")? (<DIGIT> | <LETTER>) )* >
		{
			printToken(matchedToken, "identifier");
		}
}
SPECIAL_TOKEN:
{
	< ~[] >
		{
			System.out.print("LEXICAL ERROR: ");
			System.out.printf("(%d, %d): unrecognized symbol: %s", matchedToken.beginLine,
			matchedToken.beginColumn, matchedToken.image );
		}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S () : 
{

}
{
	try {
		<tPROC> <tID> <tIS>
		declaracion_variables() declaracion_procs_funcs() bloque_sentencias()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//Si la declaraciòn del programa no està bien, es mejor saltar directamente hasta el final
		conjSinc.add(EOF);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_variables : ( declaracion <tSCOL> )*
void declaracion_variables() :
{
	
}
{
	try {
		(declaracion() <tSCOL>)*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//Esperamos un ;, el acabar de una funciòn
		conjSinc.add(tSCOL);
		conjSinc.add(tEND);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion : tipo_variable lista_vars
void declaracion() :
{
	
}
{
	try {
		tipo_variable() lista_vars()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

// tipo_variable : <tINT> | <tCHDECL> | <tBOOL>
void tipo_variable() :
{
	
}
{
	try {
		<tINT> | <tCHDECL> | <tBOOL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		conjSinc.add(tSCOL);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//lista_vars : variable ( <tCOMMA> variable )*
void lista_vars() :
{
	
}
{
	try {
		variable() ( <tCOMMA> variable() )*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//variable : LOOKAHEAD(2)
//				<tID> <tACOR> <tCONST_INT> <tCCOR>
//			|	<tID>
variable() :
{
	
}
{
	try {
		LOOKAHEAD(2)
		<tID> <tSQOP> <tNUM> <tSQCL>
	|	<tID>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_procs_funcs : ( declaracion_proc_func )*
declaracion_procs_funcs() :
{
	
}
{
	try {
		( declaracion_proc_func() )*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_proc_func :	declaracion_proceso
//						|	declaracion_funcion
declaracion_proc_func() :
{
	
}
{
	try {
		declaracion_proceso()
	|	declaracion_funcion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_proceso : cabecera_proceso declaracion_variables bloque_sentencias
declaracion_proceso() :
{
	
}
{
	try {
		cabecera_proceso() declaracion_variables() bloque_sentencias()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//cabecera_proceso : <tPROC> <tID> ( decs_parametros )? <tIS>
cabecera_proceso() :
{
	
}
{
	try {
		<tPROC> <tID> ( decs_parametros() )? <tIS>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//decs_parametros : <tPTOP> ( dec_parametros ( <tSCOL> dec_parametros )* )? <tPTCL>
decs_parametros() :
{
	
}
{
	try {
		<tPTOP> ( dec_parametros() ( <tSCOL> dec_parametros() )* )? <tPTCL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//bloque_sentencias : <tBEGIN> ( instruccion )* <tEND>
bloque_sentencias() :
{
	
}
{
	try {
		<tBEGIN> ( instruccion() )* <tEND>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//declaracion_funcion : cabecera_funcion declaracion_variables bloque_sentencias
declaracion_funcion() :
{
	
}
{
	try {
		cabecera_funcion() declaracion_variables() bloque_sentencias()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//cabecera_funcion : <tFUNC> <tID> ( decs_parametros )? <tIS>
cabecera_proceso() :
{
	
}
{
	try {
		<tFUNC> <tID> ( decs_parametros() )? <tIS>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//dec_parametros : clase_parametros tipo_variable id_or_array ( <tCOMMA> id_or_array )*
dec_parametros() :
{
	
}
{
	try {
		clase_parametros() tipo_variable() id_or_array() ( <tCOMMA> id_or_array() )*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//id_or_array : LOOKAHEAD(2)
//					<tID> <tSQOP> <tNUM> <tSQCL>
//				|	<tID>
id_or_array() :
{
	
}
{
	try {
		LOOKAHEAD(2)
		<tID> <tSQOP> <tNUM> <tSQCL>
	|	<tID>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//clase_parametros:	<tREF>
//				|	<tVAL>
clase_parametros() :
{
	
}
{
	try {
		<tREF>
	|	<tVAL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//instruccion : 	inst_leer <tSCOL>
//				|	inst_saltar_linea <tSCOL> 
//				|	inst_escribir <tSCOL> 
//				|	inst_escribir_linea <tSCOL> 
//				|LOOKAHEAD(2)
//					inst_invoc_proc <tSCOL> 
//				|	inst_asignacion <tSCOL> 
//				|	inst_seleccion
//				|	inst_iteracion
//				|	inst_return <tSCOL>
instruccion() :
{
	try {
		inst_leer() <tSCOL>
	|	inst_saltar_linea() <tSCOL> 
	|	inst_escribir() <tSCOL> 
	|	inst_escribir_linea() <tSCOL> 
	|LOOKAHEAD(2)
		inst_invoc_proc() <tSCOL> 
	|	inst_asignacion() <tSCOL> 
	|	inst_seleccion()
	|	inst_iteracion()
	|	inst_return() <tSCOL>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}
{
	
}

//inst_asignacion : asignable <tASIG> expresion
inst_asignacion() :
{
	
}
{
	try {
		asignable() <tASIG> expresion()
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//asignable : LOOKAHEAD(2)
//			|	<tID> <tSQOP> expresion <tSQCL>
//			|	<tID>
asignable() :
{
	
}
{
	try {
	LOOKAHEAD(3)
	|	<tID> <tSQOP> expresion() <tSQCL>
	|	<tID>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//inst_iteracion : <tWHIL> expresion <tDO> ( instruccion )* <tEND>
inst_iteracion() :
{
	
}
{
	try {
		<tWHIL> expresion <tDO> ( instruccion() )* <tEND>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//lista_exps: ( expresion ( <tCOMMA> expresion )* )?
lista_exps() :
{
	
}
{
	try {
		( expresion ( <tCOMMA> expresion )* )?
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//expresion : expresion_simple ( operador_relacional expresion_simple )?
expresion() :
{
	
}
{
	try {
		expresion_simple() ( operador_relacional() expresion_simple() )?
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_relacional :	<tEQ>
//					|	<tLT>
//					|	<tGT>
//					|	<tLEQ>
//					|	<tGEQ>
//					|	<tDIFF>
operador_relacional() :
{
	
}
{
	try {
		<tEQ>
	|	<tLT>
	|	<tGT>
	|	<tLEQ>
	|	<tGEQ>
	|	<tDIFF>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//expresion_simple : ( <tADD> | <tSUB> )? termino ( operador_aditivo termino )*
expresion_simple() :
{
	
}
{
	try {
		( <tADD> | <tSUB> )? termino() ( operador_aditivo() termino() )*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_aditivo :	<tADD>
//					|	<tSUB>
//					|	<tOR>
operador_aditivo() :
{
	
}
{
	try {
		<tADD>
	|	<tSUB>
	|	<tOR>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//termino : factor ( operador_multiplicativo factor )*
termino() :
{
	
}
{
	try {
		factor() ( operador_multiplicativo() factor() )*
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//operador_multiplicativo :	<tMUL>
//						|	<tMOD>
//						|	<tDIV>
//						|	<tAND>
operador_multiplicativo() :
{
	
}
{
	try {
		<tMUL>
	|	<tMOD>
	|	<tDIV>
	|	<tAND>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

//factor :	<tNOT> factor
//		|	<tPTOP> expresion <tPTCL>
//		|	<tINT2CHAR> <tPTOP> expresion <tPTCL>
//		|	<tCHAR2INT> <tPTOP> expresion <tPTCL>
//		|	LOOKAHEAD(2)  <tID> <tPTOP> lista_exps <tPTCL>
//		|	LOOKAHEAD(2)  <tID> <tSQOP> expresion <tSQCL>
//		|	<tID>
//		|	<tNUM>
//		|	<tCHAR>
//		|	<tSTRING>
//		|	<tTRUE>
//		|	<tFALSE>
factor() :
{
	
}
{
	try {
		<tNOT> factor()
	|	<tPTOP> expresion <tPTCL>
	|	<tITOA> <tPTOP> expresion <tPTCL>
	|	<tATOI> <tPTOP> expresion <tPTCL>
	|	LOOKAHEAD(2)  <tID> <tPTOP> lista_exps <tPTCL>
	|	LOOKAHEAD(2)  <tID> <tSQOP> expresion <tSQCL>
	|	<tID>
	|	<tNUM>
	|	<tCHAR>
	|	<tSTRING>
	|	<tTRUE>
	|	<tFALSE>
	} catch (ParseException e) {
		Set<Integer> conjSinc = infoParseException(e);
		//añadir tokens al conj de sincronización
		//conjSinc.add(token);
		recuperacionPanico(e.currentToken.next, conjSinc);
	}
}

JAVACODE //------------------------------------ 
//Informa sobre la excepción, y calcula el conjunto de tokens esperados Set infoParseException(ParseException e) {
Set<Integer> infoParseException(ParseException e) {
	Set<Integer> esperados = new HashSet<Integer>(); 
	System.err.println("ERROR_SINT: ('" + e.currentToken.next.image + ", " + e.currentToken.next.beginLine
		+ "," + e.currentToken.next.beginColumn + ")");
	System.err.println("Se esperaba uno de los siguientes tokens:")
	for(int i = 0; i<e.expectedTokenSequences.length; i++) {
		esperados.add(e.expectedTokenSequences[i][0]);
		System.err.println("\t" + tradConstants.tokenImage[e.expectedTokenSequences[i][0]]);
	}
	return esperados;
}

JAVACODE //--------- 
void recuperacionPanico(Token tInesperado, Set Integer> conjSinc) {
	// System.err.println(sep); 
	System.err.println("----> Recupero en modo pánico: "
		+ "\n----> saltando todo hasta token de conjunto de sincronización"); 
	System.err.println("Lexema inesperado: " + tInesperado.image);
	Token t - getNextToken();
	while (!conjSinc.contains(t. kind) && t.kind != EOF){ 
		System.err.println("Descartando token ("
		+ tradConstants.tokenImage[t.kind)
		+ "," + t.image + ")"); t - getNextToken();
	}
}




/* void S antiguo (previo a práctica 2)
void S () : 
{

}
{
	( 
		<tCHAR> | <tSTRING> | <tNUM>
		| <tPROC> | <tIS> | <tBEGIN> | <tEND> | <tRET>
		| <tBOOL> | <tCHDECL> | <tINT>
		| <tNOT> | <tIF> | <tTHEN> | <tELSE> |<tWHIL> | <tDO>
		| <tCOMMA> | <tSCOL> | <tPTOP> | <tPTCL> | <tSQOP> | <tSQCL>
		| <tSQUOT> | <tDQUOT> 
		| <tASIG> | <tADD> | <tSUB> | <tMUL> | <tDIV> | <tMOD>
		| <tGT> | <tLT> | <tEQ> | <tDIFF> | <tTRUE> | <tFALSE>
		| <tATOI> | <tITOA> | <tGET> | <tPUT> | <tPUTL> | <tFUNC> |<tVAL> | <tREF>
		| <tID>
	)+
	< EOF >
}
*/